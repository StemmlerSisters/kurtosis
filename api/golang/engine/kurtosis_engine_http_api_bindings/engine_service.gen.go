// Package engine_service provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version (devel) DO NOT EDIT.
package engine_service

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for EngineApiEnclaveAPIContainerStatus.
const (
	EnclaveAPIContainerStatusNONEXISTENT EngineApiEnclaveAPIContainerStatus = "EnclaveAPIContainerStatus_NONEXISTENT"
	EnclaveAPIContainerStatusRUNNING     EngineApiEnclaveAPIContainerStatus = "EnclaveAPIContainerStatus_RUNNING"
	EnclaveAPIContainerStatusSTOPPED     EngineApiEnclaveAPIContainerStatus = "EnclaveAPIContainerStatus_STOPPED"
)

// Defines values for EngineApiEnclaveContainersStatus.
const (
	EnclaveContainersStatusEMPTY   EngineApiEnclaveContainersStatus = "EnclaveContainersStatus_EMPTY"
	EnclaveContainersStatusRUNNING EngineApiEnclaveContainersStatus = "EnclaveContainersStatus_RUNNING"
	EnclaveContainersStatusSTOPPED EngineApiEnclaveContainersStatus = "EnclaveContainersStatus_STOPPED"
)

// Defines values for EngineApiEnclaveMode.
const (
	PRODUCTION EngineApiEnclaveMode = "PRODUCTION"
	TEST       EngineApiEnclaveMode = "TEST"
)

// Defines values for EngineApiLogLineOperator.
const (
	LogLineOperatorDOESCONTAINMATCHREGEX    EngineApiLogLineOperator = "LogLineOperator_DOES_CONTAIN_MATCH_REGEX"
	LogLineOperatorDOESCONTAINTEXT          EngineApiLogLineOperator = "LogLineOperator_DOES_CONTAIN_TEXT"
	LogLineOperatorDOESNOTCONTAINMATCHREGEX EngineApiLogLineOperator = "LogLineOperator_DOES_NOT_CONTAIN_MATCH_REGEX"
	LogLineOperatorDOESNOTCONTAINTEXT       EngineApiLogLineOperator = "LogLineOperator_DOES_NOT_CONTAIN_TEXT"
)

// EngineApiCleanArgs ==============================================================================================
// Create Enclave
// ==============================================================================================
type EngineApiCleanArgs struct {
	// ShouldCleanAll If true, It will clean even the running enclaves
	ShouldCleanAll *bool `json:"should_clean_all,omitempty"`
}

// EngineApiCleanResponse defines model for engine_api.CleanResponse.
type EngineApiCleanResponse struct {
	// RemovedEnclaveNameAndUuids removed enclave name and uuids
	RemovedEnclaveNameAndUuids *[]EngineApiEnclaveNameAndUuid `json:"removed_enclave_name_and_uuids,omitempty"`
}

// EngineApiCreateEnclaveArgs ==============================================================================================
// Create Enclave
// ==============================================================================================
type EngineApiCreateEnclaveArgs struct {
	// ApiContainerLogLevel The API container log level
	ApiContainerLogLevel *string `json:"api_container_log_level,omitempty"`

	// ApiContainerVersionTag The image tag of the API container that should be used inside the enclave
	// If blank, will use the default version that the engine server uses
	ApiContainerVersionTag *string `json:"api_container_version_tag,omitempty"`

	// EnclaveName The name of the new Kurtosis Enclave
	EnclaveName *string `json:"enclave_name,omitempty"`

	// Mode 0 - TEST
	// 1 - PRODUCTION
	Mode *EngineApiEnclaveMode `json:"mode,omitempty"`
}

// EngineApiCreateEnclaveResponse defines model for engine_api.CreateEnclaveResponse.
type EngineApiCreateEnclaveResponse struct {
	// EnclaveInfo Enclaves are defined by a network in the container system, which is why there's a bunch of network information here
	EnclaveInfo *EngineApiEnclaveInfo `json:"enclave_info,omitempty"`
}

// EngineApiDestroyEnclaveArgs ==============================================================================================
// Destroy Enclave
// ==============================================================================================
type EngineApiDestroyEnclaveArgs struct {
	// EnclaveIdentifier The identifier(uuid, shortened uuid, name) of the Kurtosis enclave to destroy
	EnclaveIdentifier *string `json:"enclave_identifier,omitempty"`
}

// EngineApiEnclaveAPIContainerHostMachineInfo Will only be present if the API container is running
type EngineApiEnclaveAPIContainerHostMachineInfo struct {
	// GrpcPortOnHostMachine The grpc port on the container engine host machine where the API container can be reached
	GrpcPortOnHostMachine *int32 `json:"grpc_port_on_host_machine,omitempty"`

	// IpOnHostMachine The interface IP on the container engine host machine where the API container can be reached
	IpOnHostMachine *string `json:"ip_on_host_machine,omitempty"`
}

// EngineApiEnclaveAPIContainerInfo defines model for engine_api.EnclaveAPIContainerInfo.
type EngineApiEnclaveAPIContainerInfo struct {
	// BridgeIpAddress this is the bridge ip address that gets assigned to api container
	BridgeIpAddress *string `json:"bridge_ip_address,omitempty"`

	// ContainerId The container engine ID of the API container
	ContainerId *string `json:"container_id,omitempty"`

	// GrpcPortInsideEnclave The grpc port inside the enclave network that the API container is listening on
	GrpcPortInsideEnclave *int32 `json:"grpc_port_inside_enclave,omitempty"`

	// IpInsideEnclave The IP inside the enclave network of the API container (i.e. how services inside the network can reach the API container)
	IpInsideEnclave *string `json:"ip_inside_enclave,omitempty"`
}

// EngineApiEnclaveAPIContainerStatus 0 - EnclaveAPIContainerStatus_NONEXISTENT // No API container exists in the enclave
// This is the only valid value when the enclave containers status is "EMPTY"
// 1 - EnclaveAPIContainerStatus_RUNNING // An API container exists and is running
// NOTE: this does NOT say that the server inside the API container is available, because checking if it's available requires making a call to the API container
// If we have a lot of API containers, we'd be making tons of calls
// 2 - EnclaveAPIContainerStatus_STOPPED // An API container exists, but isn't running
type EngineApiEnclaveAPIContainerStatus string

// EngineApiEnclaveContainersStatus 0 - EnclaveContainersStatus_EMPTY // The enclave has been created, but there are no containers inside it
// 1 - EnclaveContainersStatus_RUNNING // One or more containers are running in the enclave (which may or may not include the API container, depending on if the user was manually stopping/removing containers)
// 2 - EnclaveContainersStatus_STOPPED // There are >= 1 container in the enclave, but they're all stopped
type EngineApiEnclaveContainersStatus string

// EngineApiEnclaveIdentifiers An enclave identifier is a collection of uuid, name and shortened uuid
type EngineApiEnclaveIdentifiers struct {
	// EnclaveUuid UUID of the enclave
	EnclaveUuid *string `json:"enclave_uuid,omitempty"`

	// Name Name of the enclave
	Name *string `json:"name,omitempty"`

	// ShortenedUuid The shortened uuid of the enclave
	ShortenedUuid *string `json:"shortened_uuid,omitempty"`
}

// EngineApiEnclaveInfo Enclaves are defined by a network in the container system, which is why there's a bunch of network information here
type EngineApiEnclaveInfo struct {
	// ApiContainerHostMachineInfo Will only be present if the API container is running
	ApiContainerHostMachineInfo *EngineApiEnclaveAPIContainerHostMachineInfo `json:"api_container_host_machine_info,omitempty"`
	ApiContainerInfo            *EngineApiEnclaveAPIContainerInfo            `json:"api_container_info,omitempty"`

	// ApiContainerStatus 0 - EnclaveAPIContainerStatus_NONEXISTENT // No API container exists in the enclave
	// This is the only valid value when the enclave containers status is "EMPTY"
	// 1 - EnclaveAPIContainerStatus_RUNNING // An API container exists and is running
	// NOTE: this does NOT say that the server inside the API container is available, because checking if it's available requires making a call to the API container
	// If we have a lot of API containers, we'd be making tons of calls
	// 2 - EnclaveAPIContainerStatus_STOPPED // An API container exists, but isn't running
	ApiContainerStatus *EngineApiEnclaveAPIContainerStatus `json:"api_container_status,omitempty"`

	// ContainersStatus 0 - EnclaveContainersStatus_EMPTY // The enclave has been created, but there are no containers inside it
	// 1 - EnclaveContainersStatus_RUNNING // One or more containers are running in the enclave (which may or may not include the API container, depending on if the user was manually stopping/removing containers)
	// 2 - EnclaveContainersStatus_STOPPED // There are >= 1 container in the enclave, but they're all stopped
	ContainersStatus *EngineApiEnclaveContainersStatus `json:"containers_status,omitempty"`
	CreationTime     *GoogleProtobufTimestamp          `json:"creation_time,omitempty"`

	// EnclaveUuid UUID of the enclave
	EnclaveUuid *string `json:"enclave_uuid,omitempty"`

	// Mode 0 - TEST
	// 1 - PRODUCTION
	Mode *EngineApiEnclaveMode `json:"mode,omitempty"`

	// Name Name of the enclave
	Name *string `json:"name,omitempty"`

	// ShortenedUuid The shortened uuid of the enclave
	ShortenedUuid *string `json:"shortened_uuid,omitempty"`
}

// EngineApiEnclaveMode 0 - TEST
// 1 - PRODUCTION
type EngineApiEnclaveMode string

// EngineApiEnclaveNameAndUuid defines model for engine_api.EnclaveNameAndUuid.
type EngineApiEnclaveNameAndUuid struct {
	Name *string `json:"name,omitempty"`
	Uuid *string `json:"uuid,omitempty"`
}

// EngineApiGetEnclavesResponse defines model for engine_api.GetEnclavesResponse.
type EngineApiGetEnclavesResponse struct {
	// EnclaveInfo Enclaves are defined by a network in the container system, which is why there's a bunch of network information here
	EnclaveInfo *EngineApiEnclaveInfo `json:"enclave_info,omitempty"`
}

// EngineApiGetEngineInfoResponse ==============================================================================================
// Get Engine Info
// ==============================================================================================
type EngineApiGetEngineInfoResponse struct {
	// EngineVersion Version of the engine server
	EngineVersion *string `json:"engine_version,omitempty"`
}

// EngineApiGetExistingAndHistoricalEnclaveIdentifiersResponse defines model for engine_api.GetExistingAndHistoricalEnclaveIdentifiersResponse.
type EngineApiGetExistingAndHistoricalEnclaveIdentifiersResponse struct {
	AllIdentifiers *[]EngineApiEnclaveIdentifiers `json:"allIdentifiers,omitempty"`
}

// EngineApiGetServiceLogsArgs ==============================================================================================
// Get User Service Logs
// ==============================================================================================
type EngineApiGetServiceLogsArgs struct {
	// ConjunctiveFilters The conjunctive log lines filters, the first filter is applied over the found log lines, the second filter is applied over the filter one result and so on (like grep)
	ConjunctiveFilters *[]EngineApiLogLineFilter `json:"conjunctive_filters,omitempty"`

	// EnclaveIdentifier The identifier of the user service's Kurtosis Enclave
	EnclaveIdentifier *string `json:"enclave_identifier,omitempty"`

	// FollowLogs If true, It will follow the container logs
	FollowLogs *bool `json:"follow_logs,omitempty"`

	// NumLogLines If [return_all_logs] is false, return [num_log_lines]
	NumLogLines *int32 `json:"num_log_lines,omitempty"`

	// ReturnAllLogs If true, return all log lines
	ReturnAllLogs *bool `json:"return_all_logs,omitempty"`

	// ServiceUuidSet "Set" of service UUIDs in the enclave
	ServiceUuidSet *map[string]string `json:"service_uuid_set,omitempty"`
}

// EngineApiGetServiceLogsResponse defines model for engine_api.GetServiceLogsResponse.
type EngineApiGetServiceLogsResponse struct {
	// NotFoundServiceUuidSet A set of service GUIDs requested by the user that were not found in the logs database, could be related that users send
	// a wrong GUID or a right GUID for a service that has not sent any logs so far
	NotFoundServiceUuidSet *map[string]string `json:"not_found_service_uuid_set,omitempty"`

	// ServiceLogsByServiceUuid TODO add timestamp as well, for when we do timestamp-handling on the client side
	ServiceLogsByServiceUuid *EngineApiLogLine `json:"service_logs_by_service_uuid,omitempty"`
}

// EngineApiLogLine TODO add timestamp as well, for when we do timestamp-handling on the client side
type EngineApiLogLine struct {
	Line *[]string `json:"line,omitempty"`
}

// EngineApiLogLineFilter defines model for engine_api.LogLineFilter.
type EngineApiLogLineFilter struct {
	// Operator 0 - LogLineOperator_DOES_CONTAIN_TEXT
	// 1 - LogLineOperator_DOES_NOT_CONTAIN_TEXT
	// 2 - LogLineOperator_DOES_CONTAIN_MATCH_REGEX
	// 3 - LogLineOperator_DOES_NOT_CONTAIN_MATCH_REGEX
	Operator    *EngineApiLogLineOperator `json:"operator,omitempty"`
	TextPattern *string                   `json:"text_pattern,omitempty"`
}

// EngineApiLogLineOperator 0 - LogLineOperator_DOES_CONTAIN_TEXT
// 1 - LogLineOperator_DOES_NOT_CONTAIN_TEXT
// 2 - LogLineOperator_DOES_CONTAIN_MATCH_REGEX
// 3 - LogLineOperator_DOES_NOT_CONTAIN_MATCH_REGEX
type EngineApiLogLineOperator string

// EngineApiStopEnclaveArgs ==============================================================================================
// Stop Enclave
// ==============================================================================================
type EngineApiStopEnclaveArgs struct {
	// EnclaveIdentifier The identifier(uuid, shortened uuid, name) of the Kurtosis enclave to stop
	EnclaveIdentifier *string `json:"enclave_identifier,omitempty"`
}

// GoogleProtobufEmpty defines model for google.protobuf.Empty.
type GoogleProtobufEmpty = map[string]interface{}

// GoogleProtobufTimestamp defines model for google.protobuf.Timestamp.
type GoogleProtobufTimestamp struct {
	Nanos   *int32 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

// EngineApiEngineServiceCleanJSONRequestBody defines body for EngineApiEngineServiceClean for application/json ContentType.
type EngineApiEngineServiceCleanJSONRequestBody = EngineApiCleanArgs

// EngineApiEngineServiceCreateEnclaveJSONRequestBody defines body for EngineApiEngineServiceCreateEnclave for application/json ContentType.
type EngineApiEngineServiceCreateEnclaveJSONRequestBody = EngineApiCreateEnclaveArgs

// EngineApiEngineServiceDestroyEnclaveJSONRequestBody defines body for EngineApiEngineServiceDestroyEnclave for application/json ContentType.
type EngineApiEngineServiceDestroyEnclaveJSONRequestBody = EngineApiDestroyEnclaveArgs

// EngineApiEngineServiceGetEnclavesJSONRequestBody defines body for EngineApiEngineServiceGetEnclaves for application/json ContentType.
type EngineApiEngineServiceGetEnclavesJSONRequestBody = GoogleProtobufEmpty

// EngineApiEngineServiceGetEngineInfoJSONRequestBody defines body for EngineApiEngineServiceGetEngineInfo for application/json ContentType.
type EngineApiEngineServiceGetEngineInfoJSONRequestBody = GoogleProtobufEmpty

// EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersJSONRequestBody defines body for EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiers for application/json ContentType.
type EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersJSONRequestBody = GoogleProtobufEmpty

// EngineApiEngineServiceGetServiceLogsJSONRequestBody defines body for EngineApiEngineServiceGetServiceLogs for application/json ContentType.
type EngineApiEngineServiceGetServiceLogsJSONRequestBody = EngineApiGetServiceLogsArgs

// EngineApiEngineServiceStopEnclaveJSONRequestBody defines body for EngineApiEngineServiceStopEnclave for application/json ContentType.
type EngineApiEngineServiceStopEnclaveJSONRequestBody = EngineApiStopEnclaveArgs

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// EngineApiEngineServiceCleanWithBody request with any body
	EngineApiEngineServiceCleanWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngineApiEngineServiceClean(ctx context.Context, body EngineApiEngineServiceCleanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngineApiEngineServiceCreateEnclaveWithBody request with any body
	EngineApiEngineServiceCreateEnclaveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngineApiEngineServiceCreateEnclave(ctx context.Context, body EngineApiEngineServiceCreateEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngineApiEngineServiceDestroyEnclaveWithBody request with any body
	EngineApiEngineServiceDestroyEnclaveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngineApiEngineServiceDestroyEnclave(ctx context.Context, body EngineApiEngineServiceDestroyEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngineApiEngineServiceGetEnclavesWithBody request with any body
	EngineApiEngineServiceGetEnclavesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngineApiEngineServiceGetEnclaves(ctx context.Context, body EngineApiEngineServiceGetEnclavesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngineApiEngineServiceGetEngineInfoWithBody request with any body
	EngineApiEngineServiceGetEngineInfoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngineApiEngineServiceGetEngineInfo(ctx context.Context, body EngineApiEngineServiceGetEngineInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersWithBody request with any body
	EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiers(ctx context.Context, body EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngineApiEngineServiceGetServiceLogsWithBody request with any body
	EngineApiEngineServiceGetServiceLogsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngineApiEngineServiceGetServiceLogs(ctx context.Context, body EngineApiEngineServiceGetServiceLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EngineApiEngineServiceStopEnclaveWithBody request with any body
	EngineApiEngineServiceStopEnclaveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EngineApiEngineServiceStopEnclave(ctx context.Context, body EngineApiEngineServiceStopEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) EngineApiEngineServiceCleanWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceCleanRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceClean(ctx context.Context, body EngineApiEngineServiceCleanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceCleanRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceCreateEnclaveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceCreateEnclaveRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceCreateEnclave(ctx context.Context, body EngineApiEngineServiceCreateEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceCreateEnclaveRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceDestroyEnclaveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceDestroyEnclaveRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceDestroyEnclave(ctx context.Context, body EngineApiEngineServiceDestroyEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceDestroyEnclaveRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceGetEnclavesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceGetEnclavesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceGetEnclaves(ctx context.Context, body EngineApiEngineServiceGetEnclavesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceGetEnclavesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceGetEngineInfoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceGetEngineInfoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceGetEngineInfo(ctx context.Context, body EngineApiEngineServiceGetEngineInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceGetEngineInfoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiers(ctx context.Context, body EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceGetServiceLogsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceGetServiceLogsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceGetServiceLogs(ctx context.Context, body EngineApiEngineServiceGetServiceLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceGetServiceLogsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceStopEnclaveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceStopEnclaveRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EngineApiEngineServiceStopEnclave(ctx context.Context, body EngineApiEngineServiceStopEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEngineApiEngineServiceStopEnclaveRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewEngineApiEngineServiceCleanRequest calls the generic EngineApiEngineServiceClean builder with application/json body
func NewEngineApiEngineServiceCleanRequest(server string, body EngineApiEngineServiceCleanJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngineApiEngineServiceCleanRequestWithBody(server, "application/json", bodyReader)
}

// NewEngineApiEngineServiceCleanRequestWithBody generates requests for EngineApiEngineServiceClean with any type of body
func NewEngineApiEngineServiceCleanRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engine_api.EngineService/Clean")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngineApiEngineServiceCreateEnclaveRequest calls the generic EngineApiEngineServiceCreateEnclave builder with application/json body
func NewEngineApiEngineServiceCreateEnclaveRequest(server string, body EngineApiEngineServiceCreateEnclaveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngineApiEngineServiceCreateEnclaveRequestWithBody(server, "application/json", bodyReader)
}

// NewEngineApiEngineServiceCreateEnclaveRequestWithBody generates requests for EngineApiEngineServiceCreateEnclave with any type of body
func NewEngineApiEngineServiceCreateEnclaveRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engine_api.EngineService/CreateEnclave")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngineApiEngineServiceDestroyEnclaveRequest calls the generic EngineApiEngineServiceDestroyEnclave builder with application/json body
func NewEngineApiEngineServiceDestroyEnclaveRequest(server string, body EngineApiEngineServiceDestroyEnclaveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngineApiEngineServiceDestroyEnclaveRequestWithBody(server, "application/json", bodyReader)
}

// NewEngineApiEngineServiceDestroyEnclaveRequestWithBody generates requests for EngineApiEngineServiceDestroyEnclave with any type of body
func NewEngineApiEngineServiceDestroyEnclaveRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engine_api.EngineService/DestroyEnclave")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngineApiEngineServiceGetEnclavesRequest calls the generic EngineApiEngineServiceGetEnclaves builder with application/json body
func NewEngineApiEngineServiceGetEnclavesRequest(server string, body EngineApiEngineServiceGetEnclavesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngineApiEngineServiceGetEnclavesRequestWithBody(server, "application/json", bodyReader)
}

// NewEngineApiEngineServiceGetEnclavesRequestWithBody generates requests for EngineApiEngineServiceGetEnclaves with any type of body
func NewEngineApiEngineServiceGetEnclavesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engine_api.EngineService/GetEnclaves")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngineApiEngineServiceGetEngineInfoRequest calls the generic EngineApiEngineServiceGetEngineInfo builder with application/json body
func NewEngineApiEngineServiceGetEngineInfoRequest(server string, body EngineApiEngineServiceGetEngineInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngineApiEngineServiceGetEngineInfoRequestWithBody(server, "application/json", bodyReader)
}

// NewEngineApiEngineServiceGetEngineInfoRequestWithBody generates requests for EngineApiEngineServiceGetEngineInfo with any type of body
func NewEngineApiEngineServiceGetEngineInfoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engine_api.EngineService/GetEngineInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersRequest calls the generic EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiers builder with application/json body
func NewEngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersRequest(server string, body EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersRequestWithBody(server, "application/json", bodyReader)
}

// NewEngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersRequestWithBody generates requests for EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiers with any type of body
func NewEngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engine_api.EngineService/GetExistingAndHistoricalEnclaveIdentifiers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngineApiEngineServiceGetServiceLogsRequest calls the generic EngineApiEngineServiceGetServiceLogs builder with application/json body
func NewEngineApiEngineServiceGetServiceLogsRequest(server string, body EngineApiEngineServiceGetServiceLogsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngineApiEngineServiceGetServiceLogsRequestWithBody(server, "application/json", bodyReader)
}

// NewEngineApiEngineServiceGetServiceLogsRequestWithBody generates requests for EngineApiEngineServiceGetServiceLogs with any type of body
func NewEngineApiEngineServiceGetServiceLogsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engine_api.EngineService/GetServiceLogs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEngineApiEngineServiceStopEnclaveRequest calls the generic EngineApiEngineServiceStopEnclave builder with application/json body
func NewEngineApiEngineServiceStopEnclaveRequest(server string, body EngineApiEngineServiceStopEnclaveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEngineApiEngineServiceStopEnclaveRequestWithBody(server, "application/json", bodyReader)
}

// NewEngineApiEngineServiceStopEnclaveRequestWithBody generates requests for EngineApiEngineServiceStopEnclave with any type of body
func NewEngineApiEngineServiceStopEnclaveRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engine_api.EngineService/StopEnclave")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// EngineApiEngineServiceCleanWithBodyWithResponse request with any body
	EngineApiEngineServiceCleanWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceCleanResponse, error)

	EngineApiEngineServiceCleanWithResponse(ctx context.Context, body EngineApiEngineServiceCleanJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceCleanResponse, error)

	// EngineApiEngineServiceCreateEnclaveWithBodyWithResponse request with any body
	EngineApiEngineServiceCreateEnclaveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceCreateEnclaveResponse, error)

	EngineApiEngineServiceCreateEnclaveWithResponse(ctx context.Context, body EngineApiEngineServiceCreateEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceCreateEnclaveResponse, error)

	// EngineApiEngineServiceDestroyEnclaveWithBodyWithResponse request with any body
	EngineApiEngineServiceDestroyEnclaveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceDestroyEnclaveResponse, error)

	EngineApiEngineServiceDestroyEnclaveWithResponse(ctx context.Context, body EngineApiEngineServiceDestroyEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceDestroyEnclaveResponse, error)

	// EngineApiEngineServiceGetEnclavesWithBodyWithResponse request with any body
	EngineApiEngineServiceGetEnclavesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetEnclavesResponse, error)

	EngineApiEngineServiceGetEnclavesWithResponse(ctx context.Context, body EngineApiEngineServiceGetEnclavesJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetEnclavesResponse, error)

	// EngineApiEngineServiceGetEngineInfoWithBodyWithResponse request with any body
	EngineApiEngineServiceGetEngineInfoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetEngineInfoResponse, error)

	EngineApiEngineServiceGetEngineInfoWithResponse(ctx context.Context, body EngineApiEngineServiceGetEngineInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetEngineInfoResponse, error)

	// EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersWithBodyWithResponse request with any body
	EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse, error)

	EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersWithResponse(ctx context.Context, body EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse, error)

	// EngineApiEngineServiceGetServiceLogsWithBodyWithResponse request with any body
	EngineApiEngineServiceGetServiceLogsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetServiceLogsResponse, error)

	EngineApiEngineServiceGetServiceLogsWithResponse(ctx context.Context, body EngineApiEngineServiceGetServiceLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetServiceLogsResponse, error)

	// EngineApiEngineServiceStopEnclaveWithBodyWithResponse request with any body
	EngineApiEngineServiceStopEnclaveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceStopEnclaveResponse, error)

	EngineApiEngineServiceStopEnclaveWithResponse(ctx context.Context, body EngineApiEngineServiceStopEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceStopEnclaveResponse, error)
}

type EngineApiEngineServiceCleanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngineApiEngineServiceCleanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngineApiEngineServiceCleanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngineApiEngineServiceCreateEnclaveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngineApiEngineServiceCreateEnclaveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngineApiEngineServiceCreateEnclaveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngineApiEngineServiceDestroyEnclaveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngineApiEngineServiceDestroyEnclaveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngineApiEngineServiceDestroyEnclaveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngineApiEngineServiceGetEnclavesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngineApiEngineServiceGetEnclavesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngineApiEngineServiceGetEnclavesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngineApiEngineServiceGetEngineInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngineApiEngineServiceGetEngineInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngineApiEngineServiceGetEngineInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngineApiEngineServiceGetServiceLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngineApiEngineServiceGetServiceLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngineApiEngineServiceGetServiceLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EngineApiEngineServiceStopEnclaveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EngineApiEngineServiceStopEnclaveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EngineApiEngineServiceStopEnclaveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// EngineApiEngineServiceCleanWithBodyWithResponse request with arbitrary body returning *EngineApiEngineServiceCleanResponse
func (c *ClientWithResponses) EngineApiEngineServiceCleanWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceCleanResponse, error) {
	rsp, err := c.EngineApiEngineServiceCleanWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceCleanResponse(rsp)
}

func (c *ClientWithResponses) EngineApiEngineServiceCleanWithResponse(ctx context.Context, body EngineApiEngineServiceCleanJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceCleanResponse, error) {
	rsp, err := c.EngineApiEngineServiceClean(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceCleanResponse(rsp)
}

// EngineApiEngineServiceCreateEnclaveWithBodyWithResponse request with arbitrary body returning *EngineApiEngineServiceCreateEnclaveResponse
func (c *ClientWithResponses) EngineApiEngineServiceCreateEnclaveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceCreateEnclaveResponse, error) {
	rsp, err := c.EngineApiEngineServiceCreateEnclaveWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceCreateEnclaveResponse(rsp)
}

func (c *ClientWithResponses) EngineApiEngineServiceCreateEnclaveWithResponse(ctx context.Context, body EngineApiEngineServiceCreateEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceCreateEnclaveResponse, error) {
	rsp, err := c.EngineApiEngineServiceCreateEnclave(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceCreateEnclaveResponse(rsp)
}

// EngineApiEngineServiceDestroyEnclaveWithBodyWithResponse request with arbitrary body returning *EngineApiEngineServiceDestroyEnclaveResponse
func (c *ClientWithResponses) EngineApiEngineServiceDestroyEnclaveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceDestroyEnclaveResponse, error) {
	rsp, err := c.EngineApiEngineServiceDestroyEnclaveWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceDestroyEnclaveResponse(rsp)
}

func (c *ClientWithResponses) EngineApiEngineServiceDestroyEnclaveWithResponse(ctx context.Context, body EngineApiEngineServiceDestroyEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceDestroyEnclaveResponse, error) {
	rsp, err := c.EngineApiEngineServiceDestroyEnclave(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceDestroyEnclaveResponse(rsp)
}

// EngineApiEngineServiceGetEnclavesWithBodyWithResponse request with arbitrary body returning *EngineApiEngineServiceGetEnclavesResponse
func (c *ClientWithResponses) EngineApiEngineServiceGetEnclavesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetEnclavesResponse, error) {
	rsp, err := c.EngineApiEngineServiceGetEnclavesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceGetEnclavesResponse(rsp)
}

func (c *ClientWithResponses) EngineApiEngineServiceGetEnclavesWithResponse(ctx context.Context, body EngineApiEngineServiceGetEnclavesJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetEnclavesResponse, error) {
	rsp, err := c.EngineApiEngineServiceGetEnclaves(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceGetEnclavesResponse(rsp)
}

// EngineApiEngineServiceGetEngineInfoWithBodyWithResponse request with arbitrary body returning *EngineApiEngineServiceGetEngineInfoResponse
func (c *ClientWithResponses) EngineApiEngineServiceGetEngineInfoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetEngineInfoResponse, error) {
	rsp, err := c.EngineApiEngineServiceGetEngineInfoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceGetEngineInfoResponse(rsp)
}

func (c *ClientWithResponses) EngineApiEngineServiceGetEngineInfoWithResponse(ctx context.Context, body EngineApiEngineServiceGetEngineInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetEngineInfoResponse, error) {
	rsp, err := c.EngineApiEngineServiceGetEngineInfo(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceGetEngineInfoResponse(rsp)
}

// EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersWithBodyWithResponse request with arbitrary body returning *EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse
func (c *ClientWithResponses) EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse, error) {
	rsp, err := c.EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse(rsp)
}

func (c *ClientWithResponses) EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersWithResponse(ctx context.Context, body EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse, error) {
	rsp, err := c.EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse(rsp)
}

// EngineApiEngineServiceGetServiceLogsWithBodyWithResponse request with arbitrary body returning *EngineApiEngineServiceGetServiceLogsResponse
func (c *ClientWithResponses) EngineApiEngineServiceGetServiceLogsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetServiceLogsResponse, error) {
	rsp, err := c.EngineApiEngineServiceGetServiceLogsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceGetServiceLogsResponse(rsp)
}

func (c *ClientWithResponses) EngineApiEngineServiceGetServiceLogsWithResponse(ctx context.Context, body EngineApiEngineServiceGetServiceLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceGetServiceLogsResponse, error) {
	rsp, err := c.EngineApiEngineServiceGetServiceLogs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceGetServiceLogsResponse(rsp)
}

// EngineApiEngineServiceStopEnclaveWithBodyWithResponse request with arbitrary body returning *EngineApiEngineServiceStopEnclaveResponse
func (c *ClientWithResponses) EngineApiEngineServiceStopEnclaveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceStopEnclaveResponse, error) {
	rsp, err := c.EngineApiEngineServiceStopEnclaveWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceStopEnclaveResponse(rsp)
}

func (c *ClientWithResponses) EngineApiEngineServiceStopEnclaveWithResponse(ctx context.Context, body EngineApiEngineServiceStopEnclaveJSONRequestBody, reqEditors ...RequestEditorFn) (*EngineApiEngineServiceStopEnclaveResponse, error) {
	rsp, err := c.EngineApiEngineServiceStopEnclave(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEngineApiEngineServiceStopEnclaveResponse(rsp)
}

// ParseEngineApiEngineServiceCleanResponse parses an HTTP response from a EngineApiEngineServiceCleanWithResponse call
func ParseEngineApiEngineServiceCleanResponse(rsp *http.Response) (*EngineApiEngineServiceCleanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngineApiEngineServiceCleanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEngineApiEngineServiceCreateEnclaveResponse parses an HTTP response from a EngineApiEngineServiceCreateEnclaveWithResponse call
func ParseEngineApiEngineServiceCreateEnclaveResponse(rsp *http.Response) (*EngineApiEngineServiceCreateEnclaveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngineApiEngineServiceCreateEnclaveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEngineApiEngineServiceDestroyEnclaveResponse parses an HTTP response from a EngineApiEngineServiceDestroyEnclaveWithResponse call
func ParseEngineApiEngineServiceDestroyEnclaveResponse(rsp *http.Response) (*EngineApiEngineServiceDestroyEnclaveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngineApiEngineServiceDestroyEnclaveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEngineApiEngineServiceGetEnclavesResponse parses an HTTP response from a EngineApiEngineServiceGetEnclavesWithResponse call
func ParseEngineApiEngineServiceGetEnclavesResponse(rsp *http.Response) (*EngineApiEngineServiceGetEnclavesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngineApiEngineServiceGetEnclavesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEngineApiEngineServiceGetEngineInfoResponse parses an HTTP response from a EngineApiEngineServiceGetEngineInfoWithResponse call
func ParseEngineApiEngineServiceGetEngineInfoResponse(rsp *http.Response) (*EngineApiEngineServiceGetEngineInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngineApiEngineServiceGetEngineInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse parses an HTTP response from a EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersWithResponse call
func ParseEngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse(rsp *http.Response) (*EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEngineApiEngineServiceGetServiceLogsResponse parses an HTTP response from a EngineApiEngineServiceGetServiceLogsWithResponse call
func ParseEngineApiEngineServiceGetServiceLogsResponse(rsp *http.Response) (*EngineApiEngineServiceGetServiceLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngineApiEngineServiceGetServiceLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEngineApiEngineServiceStopEnclaveResponse parses an HTTP response from a EngineApiEngineServiceStopEnclaveWithResponse call
func ParseEngineApiEngineServiceStopEnclaveResponse(rsp *http.Response) (*EngineApiEngineServiceStopEnclaveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EngineApiEngineServiceStopEnclaveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /engine_api.EngineService/Clean)
	EngineApiEngineServiceClean(ctx echo.Context) error

	// (POST /engine_api.EngineService/CreateEnclave)
	EngineApiEngineServiceCreateEnclave(ctx echo.Context) error

	// (POST /engine_api.EngineService/DestroyEnclave)
	EngineApiEngineServiceDestroyEnclave(ctx echo.Context) error

	// (POST /engine_api.EngineService/GetEnclaves)
	EngineApiEngineServiceGetEnclaves(ctx echo.Context) error

	// (POST /engine_api.EngineService/GetEngineInfo)
	EngineApiEngineServiceGetEngineInfo(ctx echo.Context) error

	// (POST /engine_api.EngineService/GetExistingAndHistoricalEnclaveIdentifiers)
	EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiers(ctx echo.Context) error

	// (POST /engine_api.EngineService/GetServiceLogs)
	EngineApiEngineServiceGetServiceLogs(ctx echo.Context) error

	// (POST /engine_api.EngineService/StopEnclave)
	EngineApiEngineServiceStopEnclave(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// EngineApiEngineServiceClean converts echo context to params.
func (w *ServerInterfaceWrapper) EngineApiEngineServiceClean(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EngineApiEngineServiceClean(ctx)
	return err
}

// EngineApiEngineServiceCreateEnclave converts echo context to params.
func (w *ServerInterfaceWrapper) EngineApiEngineServiceCreateEnclave(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EngineApiEngineServiceCreateEnclave(ctx)
	return err
}

// EngineApiEngineServiceDestroyEnclave converts echo context to params.
func (w *ServerInterfaceWrapper) EngineApiEngineServiceDestroyEnclave(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EngineApiEngineServiceDestroyEnclave(ctx)
	return err
}

// EngineApiEngineServiceGetEnclaves converts echo context to params.
func (w *ServerInterfaceWrapper) EngineApiEngineServiceGetEnclaves(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EngineApiEngineServiceGetEnclaves(ctx)
	return err
}

// EngineApiEngineServiceGetEngineInfo converts echo context to params.
func (w *ServerInterfaceWrapper) EngineApiEngineServiceGetEngineInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EngineApiEngineServiceGetEngineInfo(ctx)
	return err
}

// EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiers converts echo context to params.
func (w *ServerInterfaceWrapper) EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiers(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiers(ctx)
	return err
}

// EngineApiEngineServiceGetServiceLogs converts echo context to params.
func (w *ServerInterfaceWrapper) EngineApiEngineServiceGetServiceLogs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EngineApiEngineServiceGetServiceLogs(ctx)
	return err
}

// EngineApiEngineServiceStopEnclave converts echo context to params.
func (w *ServerInterfaceWrapper) EngineApiEngineServiceStopEnclave(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EngineApiEngineServiceStopEnclave(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/engine_api.EngineService/Clean", wrapper.EngineApiEngineServiceClean)
	router.POST(baseURL+"/engine_api.EngineService/CreateEnclave", wrapper.EngineApiEngineServiceCreateEnclave)
	router.POST(baseURL+"/engine_api.EngineService/DestroyEnclave", wrapper.EngineApiEngineServiceDestroyEnclave)
	router.POST(baseURL+"/engine_api.EngineService/GetEnclaves", wrapper.EngineApiEngineServiceGetEnclaves)
	router.POST(baseURL+"/engine_api.EngineService/GetEngineInfo", wrapper.EngineApiEngineServiceGetEngineInfo)
	router.POST(baseURL+"/engine_api.EngineService/GetExistingAndHistoricalEnclaveIdentifiers", wrapper.EngineApiEngineServiceGetExistingAndHistoricalEnclaveIdentifiers)
	router.POST(baseURL+"/engine_api.EngineService/GetServiceLogs", wrapper.EngineApiEngineServiceGetServiceLogs)
	router.POST(baseURL+"/engine_api.EngineService/StopEnclave", wrapper.EngineApiEngineServiceStopEnclave)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Pj39JwAA//9424DrkTgAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
