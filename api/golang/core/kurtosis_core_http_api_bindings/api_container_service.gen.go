// Package api_container_service provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version (devel) DO NOT EDIT.
package api_container_service

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for Connect.
const (
	CONNECT   Connect = "CONNECT"
	NOCONNECT Connect = "NO_CONNECT"
)

// Defines values for ContainerStatus.
const (
	ContainerStatusRUNNING ContainerStatus = "RUNNING"
	ContainerStatusSTOPPED ContainerStatus = "STOPPED"
	ContainerStatusUNKNOWN ContainerStatus = "UNKNOWN"
)

// Defines values for ImageDownloadMode.
const (
	Always  ImageDownloadMode = "always"
	Missing ImageDownloadMode = "missing"
)

// Defines values for KurtosisFeatureFlag.
const (
	NOINSTRUCTIONSCACHING KurtosisFeatureFlag = "NO_INSTRUCTIONS_CACHING"
)

// Defines values for PortTransportProtocol.
const (
	SCTP PortTransportProtocol = "SCTP"
	TCP  PortTransportProtocol = "TCP"
	UDP  PortTransportProtocol = "UDP"
)

// Defines values for RestartPolicy.
const (
	ALWAYS RestartPolicy = "ALWAYS"
	NEVER  RestartPolicy = "NEVER"
)

// Defines values for ServiceStatus.
const (
	ServiceStatusRUNNING ServiceStatus = "RUNNING"
	ServiceStatusSTOPPED ServiceStatus = "STOPPED"
	ServiceStatusUNKNOWN ServiceStatus = "UNKNOWN"
)

// Defines values for WaitForEndpointAvailabilityArgsHttpMethod.
const (
	GET  WaitForEndpointAvailabilityArgsHttpMethod = "GET"
	POST WaitForEndpointAvailabilityArgsHttpMethod = "POST"
)

// Connect 0 - CONNECT // Best effort port forwarding
// 1 - NO_CONNECT // Port forwarding disabled
type Connect string

// ConnectServicesArgs defines model for ConnectServicesArgs.
type ConnectServicesArgs struct {
	// Connect 0 - CONNECT // Best effort port forwarding
	// 1 - NO_CONNECT // Port forwarding disabled
	Connect *Connect `json:"connect,omitempty"`
}

// ConnectServicesResponse defines model for ConnectServicesResponse.
type ConnectServicesResponse = map[string]interface{}

// Container defines model for Container.
type Container struct {
	CmdArgs        *[]string          `json:"cmd_args,omitempty"`
	EntrypointArgs *[]string          `json:"entrypoint_args,omitempty"`
	EnvVars        *map[string]string `json:"env_vars,omitempty"`
	ImageName      *string            `json:"image_name,omitempty"`

	// Status 0 - STOPPED
	// 1 - RUNNING
	// 2 - UNKNOWN
	Status *ContainerStatus `json:"status,omitempty"`
}

// ContainerStatus 0 - STOPPED
// 1 - RUNNING
// 2 - UNKNOWN
type ContainerStatus string

// DataChunkMetadata defines model for DataChunkMetadata.
type DataChunkMetadata struct {
	Name *string `json:"name,omitempty"`
}

// ExecCommandArgs ==============================================================================================
// Exec Command
// ==============================================================================================
type ExecCommandArgs struct {
	CommandArgs *[]string `json:"command_args,omitempty"`
}

// ExecCommandResponse defines model for ExecCommandResponse.
type ExecCommandResponse struct {
	ExitCode *int32 `json:"exit_code,omitempty"`

	// LogOutput Assumes UTF-8 encoding
	LogOutput *string `json:"log_output,omitempty"`
}

// FileArtifactContentsFileDescription defines model for FileArtifactContentsFileDescription.
type FileArtifactContentsFileDescription struct {
	// Path Path relative to the file artifact
	Path *string `json:"path,omitempty"`

	// Size Size of the file, in bytes
	Size *int64 `json:"size,omitempty"`

	// TextPreview A bit of text content, if the file allows (similar to UNIX's 'head')
	TextPreview *string `json:"text_preview,omitempty"`
}

// FilesArtifactNameAndUuid defines model for FilesArtifactNameAndUuid.
type FilesArtifactNameAndUuid struct {
	// FileName A string representing the name of the file
	FileName *string `json:"fileName,omitempty"`

	// FileUuid A string representing the uuid of the file
	FileUuid *string `json:"fileUuid,omitempty"`
}

// GetExistingAndHistoricalServiceIdentifiersResponse defines model for GetExistingAndHistoricalServiceIdentifiersResponse.
type GetExistingAndHistoricalServiceIdentifiersResponse struct {
	AllIdentifiers *[]ServiceIdentifiers `json:"allIdentifiers,omitempty"`
}

// GetServicesResponse defines model for GetServicesResponse.
type GetServicesResponse struct {
	ServiceInfo *ServiceInfo `json:"service_info,omitempty"`
}

// GetStarlarkRunResponse defines model for GetStarlarkRunResponse.
type GetStarlarkRunResponse struct {
	ExperimentalFeatures   *[]KurtosisFeatureFlag `json:"experimental_features,omitempty"`
	MainFunctionName       *string                `json:"main_function_name,omitempty"`
	PackageId              *string                `json:"package_id,omitempty"`
	Parallelism            *int32                 `json:"parallelism,omitempty"`
	RelativePathToMainFile *string                `json:"relative_path_to_main_file,omitempty"`

	// RestartPolicy 0 - NEVER
	// 1 - ALWAYS
	RestartPolicy    *RestartPolicy `json:"restart_policy,omitempty"`
	SerializedParams *string        `json:"serialized_params,omitempty"`
	SerializedScript *string        `json:"serialized_script,omitempty"`
}

// ImageDownloadMode 0 - always
// 1 - missing
type ImageDownloadMode string

// InspectFilesArtifactContentsResponse defines model for InspectFilesArtifactContentsResponse.
type InspectFilesArtifactContentsResponse struct {
	FileDescriptions *[]FileArtifactContentsFileDescription `json:"file_descriptions,omitempty"`
}

// KurtosisFeatureFlag 0 - NO_INSTRUCTIONS_CACHING
type KurtosisFeatureFlag string

// ListFilesArtifactNamesAndUuidsResponse defines model for ListFilesArtifactNamesAndUuidsResponse.
type ListFilesArtifactNamesAndUuidsResponse struct {
	FileNamesAndUuids *[]FilesArtifactNameAndUuid `json:"file_names_and_uuids,omitempty"`
}

// Port Shared Objects (Used By Multiple Endpoints)
type Port struct {
	MaybeApplicationProtocol *string `json:"maybe_application_protocol,omitempty"`

	// MaybeWaitTimeout The wait timeout duration in string
	MaybeWaitTimeout *string `json:"maybe_wait_timeout,omitempty"`
	Number           *int32  `json:"number,omitempty"`

	// TransportProtocol 0 - TCP
	// 1 - SCTP
	// 2 - UDP
	TransportProtocol *PortTransportProtocol `json:"transport_protocol,omitempty"`
}

// PortTransportProtocol 0 - TCP
// 1 - SCTP
// 2 - UDP
type PortTransportProtocol string

// RestartPolicy 0 - NEVER
// 1 - ALWAYS
type RestartPolicy string

// RunStarlarkPackageArgs defines model for RunStarlarkPackageArgs.
type RunStarlarkPackageArgs struct {
	// ClonePackage Whether the package should be cloned or not.
	// If false, then the package will be pulled from the APIC local package store. If it's a local package then is must
	// have been uploaded using UploadStarlarkPackage prior to calling RunStarlarkPackage.
	// If true, then the package will be cloned from GitHub before execution starts
	ClonePackage *bool `json:"clone_package,omitempty"`

	// CloudInstanceId Defaults to empty
	CloudInstanceId *string `json:"cloud_instance_id,omitempty"`

	// CloudUserId Defaults to empty
	CloudUserId *string `json:"cloud_user_id,omitempty"`

	// DryRun Defaults to false
	DryRun               *bool                  `json:"dry_run,omitempty"`
	ExperimentalFeatures *[]KurtosisFeatureFlag `json:"experimental_features,omitempty"`

	// ImageDownloadMode 0 - always
	// 1 - missing
	ImageDownloadMode *ImageDownloadMode `json:"image_download_mode,omitempty"`

	// Local the payload of the local module
	Local *[]byte `json:"local,omitempty"`

	// MainFunctionName The name of the main function, the default value is "run"
	MainFunctionName *string `json:"main_function_name,omitempty"`
	PackageId        *string `json:"package_id,omitempty"`

	// Parallelism Defaults to 4
	Parallelism *int32 `json:"parallelism,omitempty"`

	// RelativePathToMainFile The relative main file filepath, the default value is the "main.star" file in the root of a package
	RelativePathToMainFile *string `json:"relative_path_to_main_file,omitempty"`

	// Remote just a flag to indicate the module must be cloned inside the API
	Remote *bool `json:"remote,omitempty"`

	// SerializedParams Serialized parameters data for the Starlark package main function
	// This should be a valid JSON string
	SerializedParams *string `json:"serialized_params,omitempty"`
}

// RunStarlarkScriptArgs defines model for RunStarlarkScriptArgs.
type RunStarlarkScriptArgs struct {
	// CloudInstanceId Defaults to empty
	CloudInstanceId *string `json:"cloud_instance_id,omitempty"`

	// CloudUserId Defaults to empty
	CloudUserId *string `json:"cloud_user_id,omitempty"`

	// DryRun Defaults to false
	DryRun               *bool                  `json:"dry_run,omitempty"`
	ExperimentalFeatures *[]KurtosisFeatureFlag `json:"experimental_features,omitempty"`

	// ImageDownloadMode 0 - always
	// 1 - missing
	ImageDownloadMode *ImageDownloadMode `json:"image_download_mode,omitempty"`

	// MainFunctionName The name of the main function, the default value is "run"
	MainFunctionName *string `json:"main_function_name,omitempty"`

	// Parallelism Defaults to 4
	Parallelism      *int32  `json:"parallelism,omitempty"`
	SerializedParams *string `json:"serialized_params,omitempty"`
	SerializedScript *string `json:"serialized_script,omitempty"`
}

// ServiceIdentifiers An service identifier is a collection of uuid, name and shortened uuid
type ServiceIdentifiers struct {
	// Name Name of the service
	Name *string `json:"name,omitempty"`

	// ServiceUuid UUID of the service
	ServiceUuid *string `json:"service_uuid,omitempty"`

	// ShortenedUuid The shortened uuid of the service
	ShortenedUuid *string `json:"shortened_uuid,omitempty"`
}

// ServiceInfo defines model for ServiceInfo.
type ServiceInfo struct {
	Container *Container `json:"container,omitempty"`

	// MaybePublicIpAddr Public IP address *outside* the enclave where the service is reachable
	// NOTE: Will be empty if the service isn't running, the service didn't define any ports, or the backend doesn't support reporting public service info
	MaybePublicIpAddr *string `json:"maybe_public_ip_addr,omitempty"`

	// MaybePublicPorts Shared Objects (Used By Multiple Endpoints)
	MaybePublicPorts *Port `json:"maybe_public_ports,omitempty"`

	// Name Name of the service
	Name *string `json:"name,omitempty"`

	// PrivateIpAddr The IP address of the service inside the enclave
	PrivateIpAddr *string `json:"private_ip_addr,omitempty"`

	// PrivatePorts Shared Objects (Used By Multiple Endpoints)
	PrivatePorts *Port `json:"private_ports,omitempty"`

	// ServiceStatus 0 - STOPPED
	// 1 - RUNNING
	// 2 - UNKNOWN
	ServiceStatus *ServiceStatus `json:"service_status,omitempty"`

	// ServiceUuid UUID of the service
	ServiceUuid *string `json:"service_uuid,omitempty"`

	// ShortenedUuid Shortened uuid of the service
	ShortenedUuid *string `json:"shortened_uuid,omitempty"`
}

// ServiceStatus 0 - STOPPED
// 1 - RUNNING
// 2 - UNKNOWN
type ServiceStatus string

// StarlarkError defines model for StarlarkError.
type StarlarkError struct {
	ExecutionError      *StarlarkExecutionError      `json:"execution_error,omitempty"`
	InterpretationError *StarlarkInterpretationError `json:"interpretation_error,omitempty"`
	ValidationError     *StarlarkValidationError     `json:"validation_error,omitempty"`
}

// StarlarkExecutionError defines model for StarlarkExecutionError.
type StarlarkExecutionError struct {
	ErrorMessage *string `json:"error_message,omitempty"`
}

// StarlarkInfo defines model for StarlarkInfo.
type StarlarkInfo struct {
	InfoMessage *string `json:"info_message,omitempty"`
}

// StarlarkInstruction defines model for StarlarkInstruction.
type StarlarkInstruction struct {
	Arguments             *[]StarlarkInstructionArg    `json:"arguments,omitempty"`
	ExecutableInstruction *string                      `json:"executable_instruction,omitempty"`
	InstructionName       *string                      `json:"instruction_name,omitempty"`
	IsSkipped             *bool                        `json:"is_skipped,omitempty"`
	Position              *StarlarkInstructionPosition `json:"position,omitempty"`
}

// StarlarkInstructionArg defines model for StarlarkInstructionArg.
type StarlarkInstructionArg struct {
	ArgName            *string `json:"arg_name,omitempty"`
	IsRepresentative   *bool   `json:"is_representative,omitempty"`
	SerializedArgValue *string `json:"serialized_arg_value,omitempty"`
}

// StarlarkInstructionPosition defines model for StarlarkInstructionPosition.
type StarlarkInstructionPosition struct {
	Column   *int32  `json:"column,omitempty"`
	Filename *string `json:"filename,omitempty"`
	Line     *int32  `json:"line,omitempty"`
}

// StarlarkInstructionResult defines model for StarlarkInstructionResult.
type StarlarkInstructionResult struct {
	SerializedInstructionResult *string `json:"serialized_instruction_result,omitempty"`
}

// StarlarkInterpretationError defines model for StarlarkInterpretationError.
type StarlarkInterpretationError struct {
	ErrorMessage *string `json:"error_message,omitempty"`
}

// StarlarkRunFinishedEvent defines model for StarlarkRunFinishedEvent.
type StarlarkRunFinishedEvent struct {
	IsRunSuccessful  *bool   `json:"is_run_successful,omitempty"`
	SerializedOutput *string `json:"serialized_output,omitempty"`
}

// StarlarkRunProgress defines model for StarlarkRunProgress.
type StarlarkRunProgress struct {
	CurrentStepInfo   *[]string `json:"current_step_info,omitempty"`
	CurrentStepNumber *int32    `json:"current_step_number,omitempty"`
	TotalSteps        *int32    `json:"total_steps,omitempty"`
}

// StarlarkRunResponseLine ==============================================================================================
// Starlark Execution Response
// ==============================================================================================
type StarlarkRunResponseLine struct {
	Error             *StarlarkError             `json:"error,omitempty"`
	Info              *StarlarkInfo              `json:"info,omitempty"`
	Instruction       *StarlarkInstruction       `json:"instruction,omitempty"`
	InstructionResult *StarlarkInstructionResult `json:"instruction_result,omitempty"`
	ProgressInfo      *StarlarkRunProgress       `json:"progress_info,omitempty"`
	RunFinishedEvent  *StarlarkRunFinishedEvent  `json:"run_finished_event,omitempty"`
	Warning           *StarlarkWarning           `json:"warning,omitempty"`
}

// StarlarkValidationError defines model for StarlarkValidationError.
type StarlarkValidationError struct {
	ErrorMessage *string `json:"error_message,omitempty"`
}

// StarlarkWarning defines model for StarlarkWarning.
type StarlarkWarning struct {
	WarningMessage *string `json:"warning_message,omitempty"`
}

// StoreFilesArtifactFromServiceArgs defines model for StoreFilesArtifactFromServiceArgs.
type StoreFilesArtifactFromServiceArgs struct {
	// Name The name of the files artifact
	Name *string `json:"name,omitempty"`

	// SourcePath The absolute source path where the source files will be copied from
	SourcePath *string `json:"source_path,omitempty"`
}

// StoreFilesArtifactFromServiceResponse defines model for StoreFilesArtifactFromServiceResponse.
type StoreFilesArtifactFromServiceResponse struct {
	// Uuid UUID of the files artifact, for use when referencing it in the future
	Uuid *string `json:"uuid,omitempty"`
}

// StoreWebFilesArtifactArgs ==============================================================================================
// Store Web Files Artifact
// ==============================================================================================
type StoreWebFilesArtifactArgs struct {
	// Name The name of the files artifact
	Name *string `json:"name,omitempty"`

	// Url URL to download the artifact from
	Url *string `json:"url,omitempty"`
}

// StoreWebFilesArtifactResponse defines model for StoreWebFilesArtifactResponse.
type StoreWebFilesArtifactResponse struct {
	// Uuid UUID of the files artifact, for use when referencing it in the future
	Uuid *string `json:"uuid,omitempty"`
}

// StreamedDataChunk ==============================================================================================
// Streamed Data Chunk
// ==============================================================================================
type StreamedDataChunk struct {
	// Data Chunk of the overall files artifact bytes
	Data     *[]byte            `json:"data,omitempty"`
	Metadata *DataChunkMetadata `json:"metadata,omitempty"`

	// PreviousChunkHash Hash of the PREVIOUS chunk, or empty string is this is the first chunk
	// Referencing the previous chunk via its hash allows Kurtosis to validate
	// the consistency of the data in case some chunk were not received
	PreviousChunkHash *string `json:"previous_chunk_hash,omitempty"`
}

// UploadFilesArtifactResponse ==============================================================================================
// Upload Files Artifact
// ==============================================================================================
type UploadFilesArtifactResponse struct {
	// Name UUID of the files artifact, for use when referencing it in the future
	Name *string `json:"name,omitempty"`

	// Uuid UUID of the files artifact, for use when referencing it in the future
	Uuid *string `json:"uuid,omitempty"`
}

// WaitForEndpointAvailabilityArgs Wait For HTTP Endpoint Availability
type WaitForEndpointAvailabilityArgs struct {
	// BodyText If the endpoint returns this value, the service will be marked as available (e.g. Hello World).
	BodyText   *string                                    `json:"body_text,omitempty"`
	HttpMethod *WaitForEndpointAvailabilityArgsHttpMethod `json:"http_method,omitempty"`

	// InitialDelayMilliseconds The number of milliseconds to wait until executing the first HTTP call
	InitialDelayMilliseconds *int32 `json:"initial_delay_milliseconds,omitempty"`

	// Path The path of the service to check. It mustn't start with the first slash. For instance `service/health`
	Path *string `json:"path,omitempty"`

	// Retries Max number of HTTP call attempts that this will execute until giving up and returning an error
	Retries *int32 `json:"retries,omitempty"`

	// RetriesDelayMilliseconds Number of milliseconds to wait between retries
	RetriesDelayMilliseconds *int32 `json:"retries_delay_milliseconds,omitempty"`
}

// WaitForEndpointAvailabilityArgsHttpMethod defines model for WaitForEndpointAvailabilityArgs.HttpMethod.
type WaitForEndpointAvailabilityArgsHttpMethod string

// GoogleProtobufEmpty defines model for google.protobuf.Empty.
type GoogleProtobufEmpty = map[string]interface{}

// StreamedDataBody ==============================================================================================
// Streamed Data Chunk
// ==============================================================================================
type StreamedDataBody = StreamedDataChunk

// GetServiceServiceIdentifierParams defines parameters for GetServiceServiceIdentifier.
type GetServiceServiceIdentifierParams struct {
	// AdditionalProperties Additional properties
	AdditionalProperties *string `form:"additional-properties,omitempty" json:"additional-properties,omitempty"`
}

// PutArtifactLocalFileJSONRequestBody defines body for PutArtifactLocalFile for application/json ContentType.
type PutArtifactLocalFileJSONRequestBody = StreamedDataChunk

// PutArtifactRemoteFileJSONRequestBody defines body for PutArtifactRemoteFile for application/json ContentType.
type PutArtifactRemoteFileJSONRequestBody = StoreWebFilesArtifactArgs

// PutArtifactServiceServiceIdentifierJSONRequestBody defines body for PutArtifactServiceServiceIdentifier for application/json ContentType.
type PutArtifactServiceServiceIdentifierJSONRequestBody = StoreFilesArtifactFromServiceArgs

// PostServiceConnectionJSONRequestBody defines body for PostServiceConnection for application/json ContentType.
type PostServiceConnectionJSONRequestBody = ConnectServicesArgs

// PostServiceServiceIdentifierCommandJSONRequestBody defines body for PostServiceServiceIdentifierCommand for application/json ContentType.
type PostServiceServiceIdentifierCommandJSONRequestBody = ExecCommandArgs

// PostServiceServiceIdentifierEndpointPortNumberAvailabilityJSONRequestBody defines body for PostServiceServiceIdentifierEndpointPortNumberAvailability for application/json ContentType.
type PostServiceServiceIdentifierEndpointPortNumberAvailabilityJSONRequestBody = WaitForEndpointAvailabilityArgs

// PutStarlarkPackageJSONRequestBody defines body for PutStarlarkPackage for application/json ContentType.
type PutStarlarkPackageJSONRequestBody = StreamedDataChunk

// PostStarlarkPackagePackageIdJSONRequestBody defines body for PostStarlarkPackagePackageId for application/json ContentType.
type PostStarlarkPackagePackageIdJSONRequestBody = RunStarlarkPackageArgs

// PostStarlarkScriptJSONRequestBody defines body for PostStarlarkScript for application/json ContentType.
type PostStarlarkScriptJSONRequestBody = RunStarlarkScriptArgs

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetArtifact request
	GetArtifact(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutArtifactLocalFile request with any body
	PutArtifactLocalFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutArtifactLocalFile(ctx context.Context, body PutArtifactLocalFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutArtifactRemoteFile request with any body
	PutArtifactRemoteFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutArtifactRemoteFile(ctx context.Context, body PutArtifactRemoteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutArtifactServiceServiceIdentifier request with any body
	PutArtifactServiceServiceIdentifierWithBody(ctx context.Context, serviceIdentifier string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutArtifactServiceServiceIdentifier(ctx context.Context, serviceIdentifier string, body PutArtifactServiceServiceIdentifierJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArtifactArtifactIdentifier request
	GetArtifactArtifactIdentifier(ctx context.Context, artifactIdentifier string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArtifactArtifactIdentifierDownload request
	GetArtifactArtifactIdentifierDownload(ctx context.Context, artifactIdentifier string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetService request
	GetService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostServiceConnection request with any body
	PostServiceConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostServiceConnection(ctx context.Context, body PostServiceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceServiceIdentifier request
	GetServiceServiceIdentifier(ctx context.Context, serviceIdentifier string, params *GetServiceServiceIdentifierParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostServiceServiceIdentifierCommand request with any body
	PostServiceServiceIdentifierCommandWithBody(ctx context.Context, serviceIdentifier string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostServiceServiceIdentifierCommand(ctx context.Context, serviceIdentifier string, body PostServiceServiceIdentifierCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostServiceServiceIdentifierEndpointPortNumberAvailability request with any body
	PostServiceServiceIdentifierEndpointPortNumberAvailabilityWithBody(ctx context.Context, serviceIdentifier string, portNumber int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostServiceServiceIdentifierEndpointPortNumberAvailability(ctx context.Context, serviceIdentifier string, portNumber int, body PostServiceServiceIdentifierEndpointPortNumberAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStarlark request
	GetStarlark(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutStarlarkPackage request with any body
	PutStarlarkPackageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutStarlarkPackage(ctx context.Context, body PutStarlarkPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStarlarkPackagePackageId request with any body
	PostStarlarkPackagePackageIdWithBody(ctx context.Context, packageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStarlarkPackagePackageId(ctx context.Context, packageId string, body PostStarlarkPackagePackageIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStarlarkScript request with any body
	PostStarlarkScriptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStarlarkScript(ctx context.Context, body PostStarlarkScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetArtifact(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArtifactRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutArtifactLocalFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutArtifactLocalFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutArtifactLocalFile(ctx context.Context, body PutArtifactLocalFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutArtifactLocalFileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutArtifactRemoteFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutArtifactRemoteFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutArtifactRemoteFile(ctx context.Context, body PutArtifactRemoteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutArtifactRemoteFileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutArtifactServiceServiceIdentifierWithBody(ctx context.Context, serviceIdentifier string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutArtifactServiceServiceIdentifierRequestWithBody(c.Server, serviceIdentifier, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutArtifactServiceServiceIdentifier(ctx context.Context, serviceIdentifier string, body PutArtifactServiceServiceIdentifierJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutArtifactServiceServiceIdentifierRequest(c.Server, serviceIdentifier, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArtifactArtifactIdentifier(ctx context.Context, artifactIdentifier string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArtifactArtifactIdentifierRequest(c.Server, artifactIdentifier)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArtifactArtifactIdentifierDownload(ctx context.Context, artifactIdentifier string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArtifactArtifactIdentifierDownloadRequest(c.Server, artifactIdentifier)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServiceConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServiceConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServiceConnection(ctx context.Context, body PostServiceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServiceConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceServiceIdentifier(ctx context.Context, serviceIdentifier string, params *GetServiceServiceIdentifierParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceServiceIdentifierRequest(c.Server, serviceIdentifier, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServiceServiceIdentifierCommandWithBody(ctx context.Context, serviceIdentifier string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServiceServiceIdentifierCommandRequestWithBody(c.Server, serviceIdentifier, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServiceServiceIdentifierCommand(ctx context.Context, serviceIdentifier string, body PostServiceServiceIdentifierCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServiceServiceIdentifierCommandRequest(c.Server, serviceIdentifier, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServiceServiceIdentifierEndpointPortNumberAvailabilityWithBody(ctx context.Context, serviceIdentifier string, portNumber int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServiceServiceIdentifierEndpointPortNumberAvailabilityRequestWithBody(c.Server, serviceIdentifier, portNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServiceServiceIdentifierEndpointPortNumberAvailability(ctx context.Context, serviceIdentifier string, portNumber int, body PostServiceServiceIdentifierEndpointPortNumberAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServiceServiceIdentifierEndpointPortNumberAvailabilityRequest(c.Server, serviceIdentifier, portNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStarlark(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStarlarkRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutStarlarkPackageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutStarlarkPackageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutStarlarkPackage(ctx context.Context, body PutStarlarkPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutStarlarkPackageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStarlarkPackagePackageIdWithBody(ctx context.Context, packageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStarlarkPackagePackageIdRequestWithBody(c.Server, packageId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStarlarkPackagePackageId(ctx context.Context, packageId string, body PostStarlarkPackagePackageIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStarlarkPackagePackageIdRequest(c.Server, packageId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStarlarkScriptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStarlarkScriptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStarlarkScript(ctx context.Context, body PostStarlarkScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStarlarkScriptRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetArtifactRequest generates requests for GetArtifact
func NewGetArtifactRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifact")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutArtifactLocalFileRequest calls the generic PutArtifactLocalFile builder with application/json body
func NewPutArtifactLocalFileRequest(server string, body PutArtifactLocalFileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutArtifactLocalFileRequestWithBody(server, "application/json", bodyReader)
}

// NewPutArtifactLocalFileRequestWithBody generates requests for PutArtifactLocalFile with any type of body
func NewPutArtifactLocalFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifact/local-file")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutArtifactRemoteFileRequest calls the generic PutArtifactRemoteFile builder with application/json body
func NewPutArtifactRemoteFileRequest(server string, body PutArtifactRemoteFileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutArtifactRemoteFileRequestWithBody(server, "application/json", bodyReader)
}

// NewPutArtifactRemoteFileRequestWithBody generates requests for PutArtifactRemoteFile with any type of body
func NewPutArtifactRemoteFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifact/remote-file")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutArtifactServiceServiceIdentifierRequest calls the generic PutArtifactServiceServiceIdentifier builder with application/json body
func NewPutArtifactServiceServiceIdentifierRequest(server string, serviceIdentifier string, body PutArtifactServiceServiceIdentifierJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutArtifactServiceServiceIdentifierRequestWithBody(server, serviceIdentifier, "application/json", bodyReader)
}

// NewPutArtifactServiceServiceIdentifierRequestWithBody generates requests for PutArtifactServiceServiceIdentifier with any type of body
func NewPutArtifactServiceServiceIdentifierRequestWithBody(server string, serviceIdentifier string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, serviceIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifact/service/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetArtifactArtifactIdentifierRequest generates requests for GetArtifactArtifactIdentifier
func NewGetArtifactArtifactIdentifierRequest(server string, artifactIdentifier string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "artifact_identifier", runtime.ParamLocationPath, artifactIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifact/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArtifactArtifactIdentifierDownloadRequest generates requests for GetArtifactArtifactIdentifierDownload
func NewGetArtifactArtifactIdentifierDownloadRequest(server string, artifactIdentifier string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "artifact_identifier", runtime.ParamLocationPath, artifactIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifact/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceRequest generates requests for GetService
func NewGetServiceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostServiceConnectionRequest calls the generic PostServiceConnection builder with application/json body
func NewPostServiceConnectionRequest(server string, body PostServiceConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostServiceConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewPostServiceConnectionRequestWithBody generates requests for PostServiceConnection with any type of body
func NewPostServiceConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/connection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServiceServiceIdentifierRequest generates requests for GetServiceServiceIdentifier
func NewGetServiceServiceIdentifierRequest(server string, serviceIdentifier string, params *GetServiceServiceIdentifierParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, serviceIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AdditionalProperties != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additional-properties", runtime.ParamLocationQuery, *params.AdditionalProperties); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostServiceServiceIdentifierCommandRequest calls the generic PostServiceServiceIdentifierCommand builder with application/json body
func NewPostServiceServiceIdentifierCommandRequest(server string, serviceIdentifier string, body PostServiceServiceIdentifierCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostServiceServiceIdentifierCommandRequestWithBody(server, serviceIdentifier, "application/json", bodyReader)
}

// NewPostServiceServiceIdentifierCommandRequestWithBody generates requests for PostServiceServiceIdentifierCommand with any type of body
func NewPostServiceServiceIdentifierCommandRequestWithBody(server string, serviceIdentifier string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, serviceIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/%s/command", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostServiceServiceIdentifierEndpointPortNumberAvailabilityRequest calls the generic PostServiceServiceIdentifierEndpointPortNumberAvailability builder with application/json body
func NewPostServiceServiceIdentifierEndpointPortNumberAvailabilityRequest(server string, serviceIdentifier string, portNumber int, body PostServiceServiceIdentifierEndpointPortNumberAvailabilityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostServiceServiceIdentifierEndpointPortNumberAvailabilityRequestWithBody(server, serviceIdentifier, portNumber, "application/json", bodyReader)
}

// NewPostServiceServiceIdentifierEndpointPortNumberAvailabilityRequestWithBody generates requests for PostServiceServiceIdentifierEndpointPortNumberAvailability with any type of body
func NewPostServiceServiceIdentifierEndpointPortNumberAvailabilityRequestWithBody(server string, serviceIdentifier string, portNumber int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, serviceIdentifier)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "port_number", runtime.ParamLocationPath, portNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/%s/endpoint/%s/availability", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStarlarkRequest generates requests for GetStarlark
func NewGetStarlarkRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/starlark")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutStarlarkPackageRequest calls the generic PutStarlarkPackage builder with application/json body
func NewPutStarlarkPackageRequest(server string, body PutStarlarkPackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutStarlarkPackageRequestWithBody(server, "application/json", bodyReader)
}

// NewPutStarlarkPackageRequestWithBody generates requests for PutStarlarkPackage with any type of body
func NewPutStarlarkPackageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/starlark/package")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStarlarkPackagePackageIdRequest calls the generic PostStarlarkPackagePackageId builder with application/json body
func NewPostStarlarkPackagePackageIdRequest(server string, packageId string, body PostStarlarkPackagePackageIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStarlarkPackagePackageIdRequestWithBody(server, packageId, "application/json", bodyReader)
}

// NewPostStarlarkPackagePackageIdRequestWithBody generates requests for PostStarlarkPackagePackageId with any type of body
func NewPostStarlarkPackagePackageIdRequestWithBody(server string, packageId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "package_id", runtime.ParamLocationPath, packageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/starlark/package/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStarlarkScriptRequest calls the generic PostStarlarkScript builder with application/json body
func NewPostStarlarkScriptRequest(server string, body PostStarlarkScriptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStarlarkScriptRequestWithBody(server, "application/json", bodyReader)
}

// NewPostStarlarkScriptRequestWithBody generates requests for PostStarlarkScript with any type of body
func NewPostStarlarkScriptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/starlark/script")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetArtifact request
	GetArtifactWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetArtifactResponse, error)

	// PutArtifactLocalFile request with any body
	PutArtifactLocalFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutArtifactLocalFileResponse, error)

	PutArtifactLocalFileWithResponse(ctx context.Context, body PutArtifactLocalFileJSONRequestBody, reqEditors ...RequestEditorFn) (*PutArtifactLocalFileResponse, error)

	// PutArtifactRemoteFile request with any body
	PutArtifactRemoteFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutArtifactRemoteFileResponse, error)

	PutArtifactRemoteFileWithResponse(ctx context.Context, body PutArtifactRemoteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*PutArtifactRemoteFileResponse, error)

	// PutArtifactServiceServiceIdentifier request with any body
	PutArtifactServiceServiceIdentifierWithBodyWithResponse(ctx context.Context, serviceIdentifier string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutArtifactServiceServiceIdentifierResponse, error)

	PutArtifactServiceServiceIdentifierWithResponse(ctx context.Context, serviceIdentifier string, body PutArtifactServiceServiceIdentifierJSONRequestBody, reqEditors ...RequestEditorFn) (*PutArtifactServiceServiceIdentifierResponse, error)

	// GetArtifactArtifactIdentifier request
	GetArtifactArtifactIdentifierWithResponse(ctx context.Context, artifactIdentifier string, reqEditors ...RequestEditorFn) (*GetArtifactArtifactIdentifierResponse, error)

	// GetArtifactArtifactIdentifierDownload request
	GetArtifactArtifactIdentifierDownloadWithResponse(ctx context.Context, artifactIdentifier string, reqEditors ...RequestEditorFn) (*GetArtifactArtifactIdentifierDownloadResponse, error)

	// GetService request
	GetServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServiceResponse, error)

	// PostServiceConnection request with any body
	PostServiceConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServiceConnectionResponse, error)

	PostServiceConnectionWithResponse(ctx context.Context, body PostServiceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServiceConnectionResponse, error)

	// GetServiceServiceIdentifier request
	GetServiceServiceIdentifierWithResponse(ctx context.Context, serviceIdentifier string, params *GetServiceServiceIdentifierParams, reqEditors ...RequestEditorFn) (*GetServiceServiceIdentifierResponse, error)

	// PostServiceServiceIdentifierCommand request with any body
	PostServiceServiceIdentifierCommandWithBodyWithResponse(ctx context.Context, serviceIdentifier string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServiceServiceIdentifierCommandResponse, error)

	PostServiceServiceIdentifierCommandWithResponse(ctx context.Context, serviceIdentifier string, body PostServiceServiceIdentifierCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServiceServiceIdentifierCommandResponse, error)

	// PostServiceServiceIdentifierEndpointPortNumberAvailability request with any body
	PostServiceServiceIdentifierEndpointPortNumberAvailabilityWithBodyWithResponse(ctx context.Context, serviceIdentifier string, portNumber int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse, error)

	PostServiceServiceIdentifierEndpointPortNumberAvailabilityWithResponse(ctx context.Context, serviceIdentifier string, portNumber int, body PostServiceServiceIdentifierEndpointPortNumberAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse, error)

	// GetStarlark request
	GetStarlarkWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStarlarkResponse, error)

	// PutStarlarkPackage request with any body
	PutStarlarkPackageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutStarlarkPackageResponse, error)

	PutStarlarkPackageWithResponse(ctx context.Context, body PutStarlarkPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*PutStarlarkPackageResponse, error)

	// PostStarlarkPackagePackageId request with any body
	PostStarlarkPackagePackageIdWithBodyWithResponse(ctx context.Context, packageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStarlarkPackagePackageIdResponse, error)

	PostStarlarkPackagePackageIdWithResponse(ctx context.Context, packageId string, body PostStarlarkPackagePackageIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStarlarkPackagePackageIdResponse, error)

	// PostStarlarkScript request with any body
	PostStarlarkScriptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStarlarkScriptResponse, error)

	PostStarlarkScriptWithResponse(ctx context.Context, body PostStarlarkScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStarlarkScriptResponse, error)
}

type GetArtifactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetArtifactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArtifactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutArtifactLocalFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutArtifactLocalFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutArtifactLocalFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutArtifactRemoteFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutArtifactRemoteFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutArtifactRemoteFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutArtifactServiceServiceIdentifierResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutArtifactServiceServiceIdentifierResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutArtifactServiceServiceIdentifierResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArtifactArtifactIdentifierResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetArtifactArtifactIdentifierResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArtifactArtifactIdentifierResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArtifactArtifactIdentifierDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetArtifactArtifactIdentifierDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArtifactArtifactIdentifierDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostServiceConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostServiceConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostServiceConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceServiceIdentifierResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetServiceServiceIdentifierResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceServiceIdentifierResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostServiceServiceIdentifierCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostServiceServiceIdentifierCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostServiceServiceIdentifierCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStarlarkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStarlarkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStarlarkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutStarlarkPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutStarlarkPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutStarlarkPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStarlarkPackagePackageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostStarlarkPackagePackageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStarlarkPackagePackageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStarlarkScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostStarlarkScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStarlarkScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetArtifactWithResponse request returning *GetArtifactResponse
func (c *ClientWithResponses) GetArtifactWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetArtifactResponse, error) {
	rsp, err := c.GetArtifact(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArtifactResponse(rsp)
}

// PutArtifactLocalFileWithBodyWithResponse request with arbitrary body returning *PutArtifactLocalFileResponse
func (c *ClientWithResponses) PutArtifactLocalFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutArtifactLocalFileResponse, error) {
	rsp, err := c.PutArtifactLocalFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutArtifactLocalFileResponse(rsp)
}

func (c *ClientWithResponses) PutArtifactLocalFileWithResponse(ctx context.Context, body PutArtifactLocalFileJSONRequestBody, reqEditors ...RequestEditorFn) (*PutArtifactLocalFileResponse, error) {
	rsp, err := c.PutArtifactLocalFile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutArtifactLocalFileResponse(rsp)
}

// PutArtifactRemoteFileWithBodyWithResponse request with arbitrary body returning *PutArtifactRemoteFileResponse
func (c *ClientWithResponses) PutArtifactRemoteFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutArtifactRemoteFileResponse, error) {
	rsp, err := c.PutArtifactRemoteFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutArtifactRemoteFileResponse(rsp)
}

func (c *ClientWithResponses) PutArtifactRemoteFileWithResponse(ctx context.Context, body PutArtifactRemoteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*PutArtifactRemoteFileResponse, error) {
	rsp, err := c.PutArtifactRemoteFile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutArtifactRemoteFileResponse(rsp)
}

// PutArtifactServiceServiceIdentifierWithBodyWithResponse request with arbitrary body returning *PutArtifactServiceServiceIdentifierResponse
func (c *ClientWithResponses) PutArtifactServiceServiceIdentifierWithBodyWithResponse(ctx context.Context, serviceIdentifier string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutArtifactServiceServiceIdentifierResponse, error) {
	rsp, err := c.PutArtifactServiceServiceIdentifierWithBody(ctx, serviceIdentifier, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutArtifactServiceServiceIdentifierResponse(rsp)
}

func (c *ClientWithResponses) PutArtifactServiceServiceIdentifierWithResponse(ctx context.Context, serviceIdentifier string, body PutArtifactServiceServiceIdentifierJSONRequestBody, reqEditors ...RequestEditorFn) (*PutArtifactServiceServiceIdentifierResponse, error) {
	rsp, err := c.PutArtifactServiceServiceIdentifier(ctx, serviceIdentifier, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutArtifactServiceServiceIdentifierResponse(rsp)
}

// GetArtifactArtifactIdentifierWithResponse request returning *GetArtifactArtifactIdentifierResponse
func (c *ClientWithResponses) GetArtifactArtifactIdentifierWithResponse(ctx context.Context, artifactIdentifier string, reqEditors ...RequestEditorFn) (*GetArtifactArtifactIdentifierResponse, error) {
	rsp, err := c.GetArtifactArtifactIdentifier(ctx, artifactIdentifier, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArtifactArtifactIdentifierResponse(rsp)
}

// GetArtifactArtifactIdentifierDownloadWithResponse request returning *GetArtifactArtifactIdentifierDownloadResponse
func (c *ClientWithResponses) GetArtifactArtifactIdentifierDownloadWithResponse(ctx context.Context, artifactIdentifier string, reqEditors ...RequestEditorFn) (*GetArtifactArtifactIdentifierDownloadResponse, error) {
	rsp, err := c.GetArtifactArtifactIdentifierDownload(ctx, artifactIdentifier, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArtifactArtifactIdentifierDownloadResponse(rsp)
}

// GetServiceWithResponse request returning *GetServiceResponse
func (c *ClientWithResponses) GetServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServiceResponse, error) {
	rsp, err := c.GetService(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceResponse(rsp)
}

// PostServiceConnectionWithBodyWithResponse request with arbitrary body returning *PostServiceConnectionResponse
func (c *ClientWithResponses) PostServiceConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServiceConnectionResponse, error) {
	rsp, err := c.PostServiceConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServiceConnectionResponse(rsp)
}

func (c *ClientWithResponses) PostServiceConnectionWithResponse(ctx context.Context, body PostServiceConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServiceConnectionResponse, error) {
	rsp, err := c.PostServiceConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServiceConnectionResponse(rsp)
}

// GetServiceServiceIdentifierWithResponse request returning *GetServiceServiceIdentifierResponse
func (c *ClientWithResponses) GetServiceServiceIdentifierWithResponse(ctx context.Context, serviceIdentifier string, params *GetServiceServiceIdentifierParams, reqEditors ...RequestEditorFn) (*GetServiceServiceIdentifierResponse, error) {
	rsp, err := c.GetServiceServiceIdentifier(ctx, serviceIdentifier, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceServiceIdentifierResponse(rsp)
}

// PostServiceServiceIdentifierCommandWithBodyWithResponse request with arbitrary body returning *PostServiceServiceIdentifierCommandResponse
func (c *ClientWithResponses) PostServiceServiceIdentifierCommandWithBodyWithResponse(ctx context.Context, serviceIdentifier string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServiceServiceIdentifierCommandResponse, error) {
	rsp, err := c.PostServiceServiceIdentifierCommandWithBody(ctx, serviceIdentifier, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServiceServiceIdentifierCommandResponse(rsp)
}

func (c *ClientWithResponses) PostServiceServiceIdentifierCommandWithResponse(ctx context.Context, serviceIdentifier string, body PostServiceServiceIdentifierCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServiceServiceIdentifierCommandResponse, error) {
	rsp, err := c.PostServiceServiceIdentifierCommand(ctx, serviceIdentifier, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServiceServiceIdentifierCommandResponse(rsp)
}

// PostServiceServiceIdentifierEndpointPortNumberAvailabilityWithBodyWithResponse request with arbitrary body returning *PostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse
func (c *ClientWithResponses) PostServiceServiceIdentifierEndpointPortNumberAvailabilityWithBodyWithResponse(ctx context.Context, serviceIdentifier string, portNumber int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse, error) {
	rsp, err := c.PostServiceServiceIdentifierEndpointPortNumberAvailabilityWithBody(ctx, serviceIdentifier, portNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse(rsp)
}

func (c *ClientWithResponses) PostServiceServiceIdentifierEndpointPortNumberAvailabilityWithResponse(ctx context.Context, serviceIdentifier string, portNumber int, body PostServiceServiceIdentifierEndpointPortNumberAvailabilityJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse, error) {
	rsp, err := c.PostServiceServiceIdentifierEndpointPortNumberAvailability(ctx, serviceIdentifier, portNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse(rsp)
}

// GetStarlarkWithResponse request returning *GetStarlarkResponse
func (c *ClientWithResponses) GetStarlarkWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStarlarkResponse, error) {
	rsp, err := c.GetStarlark(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStarlarkResponse(rsp)
}

// PutStarlarkPackageWithBodyWithResponse request with arbitrary body returning *PutStarlarkPackageResponse
func (c *ClientWithResponses) PutStarlarkPackageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutStarlarkPackageResponse, error) {
	rsp, err := c.PutStarlarkPackageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutStarlarkPackageResponse(rsp)
}

func (c *ClientWithResponses) PutStarlarkPackageWithResponse(ctx context.Context, body PutStarlarkPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*PutStarlarkPackageResponse, error) {
	rsp, err := c.PutStarlarkPackage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutStarlarkPackageResponse(rsp)
}

// PostStarlarkPackagePackageIdWithBodyWithResponse request with arbitrary body returning *PostStarlarkPackagePackageIdResponse
func (c *ClientWithResponses) PostStarlarkPackagePackageIdWithBodyWithResponse(ctx context.Context, packageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStarlarkPackagePackageIdResponse, error) {
	rsp, err := c.PostStarlarkPackagePackageIdWithBody(ctx, packageId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStarlarkPackagePackageIdResponse(rsp)
}

func (c *ClientWithResponses) PostStarlarkPackagePackageIdWithResponse(ctx context.Context, packageId string, body PostStarlarkPackagePackageIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStarlarkPackagePackageIdResponse, error) {
	rsp, err := c.PostStarlarkPackagePackageId(ctx, packageId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStarlarkPackagePackageIdResponse(rsp)
}

// PostStarlarkScriptWithBodyWithResponse request with arbitrary body returning *PostStarlarkScriptResponse
func (c *ClientWithResponses) PostStarlarkScriptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStarlarkScriptResponse, error) {
	rsp, err := c.PostStarlarkScriptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStarlarkScriptResponse(rsp)
}

func (c *ClientWithResponses) PostStarlarkScriptWithResponse(ctx context.Context, body PostStarlarkScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStarlarkScriptResponse, error) {
	rsp, err := c.PostStarlarkScript(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStarlarkScriptResponse(rsp)
}

// ParseGetArtifactResponse parses an HTTP response from a GetArtifactWithResponse call
func ParseGetArtifactResponse(rsp *http.Response) (*GetArtifactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArtifactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePutArtifactLocalFileResponse parses an HTTP response from a PutArtifactLocalFileWithResponse call
func ParsePutArtifactLocalFileResponse(rsp *http.Response) (*PutArtifactLocalFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutArtifactLocalFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePutArtifactRemoteFileResponse parses an HTTP response from a PutArtifactRemoteFileWithResponse call
func ParsePutArtifactRemoteFileResponse(rsp *http.Response) (*PutArtifactRemoteFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutArtifactRemoteFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePutArtifactServiceServiceIdentifierResponse parses an HTTP response from a PutArtifactServiceServiceIdentifierWithResponse call
func ParsePutArtifactServiceServiceIdentifierResponse(rsp *http.Response) (*PutArtifactServiceServiceIdentifierResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutArtifactServiceServiceIdentifierResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetArtifactArtifactIdentifierResponse parses an HTTP response from a GetArtifactArtifactIdentifierWithResponse call
func ParseGetArtifactArtifactIdentifierResponse(rsp *http.Response) (*GetArtifactArtifactIdentifierResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArtifactArtifactIdentifierResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetArtifactArtifactIdentifierDownloadResponse parses an HTTP response from a GetArtifactArtifactIdentifierDownloadWithResponse call
func ParseGetArtifactArtifactIdentifierDownloadResponse(rsp *http.Response) (*GetArtifactArtifactIdentifierDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArtifactArtifactIdentifierDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetServiceResponse parses an HTTP response from a GetServiceWithResponse call
func ParseGetServiceResponse(rsp *http.Response) (*GetServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostServiceConnectionResponse parses an HTTP response from a PostServiceConnectionWithResponse call
func ParsePostServiceConnectionResponse(rsp *http.Response) (*PostServiceConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostServiceConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetServiceServiceIdentifierResponse parses an HTTP response from a GetServiceServiceIdentifierWithResponse call
func ParseGetServiceServiceIdentifierResponse(rsp *http.Response) (*GetServiceServiceIdentifierResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceServiceIdentifierResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostServiceServiceIdentifierCommandResponse parses an HTTP response from a PostServiceServiceIdentifierCommandWithResponse call
func ParsePostServiceServiceIdentifierCommandResponse(rsp *http.Response) (*PostServiceServiceIdentifierCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostServiceServiceIdentifierCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse parses an HTTP response from a PostServiceServiceIdentifierEndpointPortNumberAvailabilityWithResponse call
func ParsePostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse(rsp *http.Response) (*PostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostServiceServiceIdentifierEndpointPortNumberAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStarlarkResponse parses an HTTP response from a GetStarlarkWithResponse call
func ParseGetStarlarkResponse(rsp *http.Response) (*GetStarlarkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStarlarkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePutStarlarkPackageResponse parses an HTTP response from a PutStarlarkPackageWithResponse call
func ParsePutStarlarkPackageResponse(rsp *http.Response) (*PutStarlarkPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutStarlarkPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostStarlarkPackagePackageIdResponse parses an HTTP response from a PostStarlarkPackagePackageIdWithResponse call
func ParsePostStarlarkPackagePackageIdResponse(rsp *http.Response) (*PostStarlarkPackagePackageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStarlarkPackagePackageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostStarlarkScriptResponse parses an HTTP response from a PostStarlarkScriptWithResponse call
func ParsePostStarlarkScriptResponse(rsp *http.Response) (*PostStarlarkScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStarlarkScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /artifact)
	GetArtifact(ctx echo.Context) error

	// (PUT /artifact/local-file)
	PutArtifactLocalFile(ctx echo.Context) error

	// (PUT /artifact/remote-file)
	PutArtifactRemoteFile(ctx echo.Context) error

	// (PUT /artifact/service/{service_identifier})
	PutArtifactServiceServiceIdentifier(ctx echo.Context, serviceIdentifier string) error

	// (GET /artifact/{artifact_identifier})
	GetArtifactArtifactIdentifier(ctx echo.Context, artifactIdentifier string) error

	// (GET /artifact/{artifact_identifier}/download)
	GetArtifactArtifactIdentifierDownload(ctx echo.Context, artifactIdentifier string) error

	// (GET /service)
	GetService(ctx echo.Context) error

	// (POST /service/connection)
	PostServiceConnection(ctx echo.Context) error

	// (GET /service/{service_identifier})
	GetServiceServiceIdentifier(ctx echo.Context, serviceIdentifier string, params GetServiceServiceIdentifierParams) error

	// (POST /service/{service_identifier}/command)
	PostServiceServiceIdentifierCommand(ctx echo.Context, serviceIdentifier string) error

	// (POST /service/{service_identifier}/endpoint/{port_number}/availability)
	PostServiceServiceIdentifierEndpointPortNumberAvailability(ctx echo.Context, serviceIdentifier string, portNumber int) error

	// (GET /starlark)
	GetStarlark(ctx echo.Context) error

	// (PUT /starlark/package)
	PutStarlarkPackage(ctx echo.Context) error

	// (POST /starlark/package/{package_id})
	PostStarlarkPackagePackageId(ctx echo.Context, packageId string) error

	// (POST /starlark/script)
	PostStarlarkScript(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetArtifact converts echo context to params.
func (w *ServerInterfaceWrapper) GetArtifact(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArtifact(ctx)
	return err
}

// PutArtifactLocalFile converts echo context to params.
func (w *ServerInterfaceWrapper) PutArtifactLocalFile(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutArtifactLocalFile(ctx)
	return err
}

// PutArtifactRemoteFile converts echo context to params.
func (w *ServerInterfaceWrapper) PutArtifactRemoteFile(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutArtifactRemoteFile(ctx)
	return err
}

// PutArtifactServiceServiceIdentifier converts echo context to params.
func (w *ServerInterfaceWrapper) PutArtifactServiceServiceIdentifier(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "service_identifier" -------------
	var serviceIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, ctx.Param("service_identifier"), &serviceIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutArtifactServiceServiceIdentifier(ctx, serviceIdentifier)
	return err
}

// GetArtifactArtifactIdentifier converts echo context to params.
func (w *ServerInterfaceWrapper) GetArtifactArtifactIdentifier(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "artifact_identifier" -------------
	var artifactIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "artifact_identifier", runtime.ParamLocationPath, ctx.Param("artifact_identifier"), &artifactIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter artifact_identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArtifactArtifactIdentifier(ctx, artifactIdentifier)
	return err
}

// GetArtifactArtifactIdentifierDownload converts echo context to params.
func (w *ServerInterfaceWrapper) GetArtifactArtifactIdentifierDownload(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "artifact_identifier" -------------
	var artifactIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "artifact_identifier", runtime.ParamLocationPath, ctx.Param("artifact_identifier"), &artifactIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter artifact_identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArtifactArtifactIdentifierDownload(ctx, artifactIdentifier)
	return err
}

// GetService converts echo context to params.
func (w *ServerInterfaceWrapper) GetService(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetService(ctx)
	return err
}

// PostServiceConnection converts echo context to params.
func (w *ServerInterfaceWrapper) PostServiceConnection(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostServiceConnection(ctx)
	return err
}

// GetServiceServiceIdentifier converts echo context to params.
func (w *ServerInterfaceWrapper) GetServiceServiceIdentifier(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "service_identifier" -------------
	var serviceIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, ctx.Param("service_identifier"), &serviceIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_identifier: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetServiceServiceIdentifierParams
	// ------------- Optional query parameter "additional-properties" -------------

	err = runtime.BindQueryParameter("form", true, false, "additional-properties", ctx.QueryParams(), &params.AdditionalProperties)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter additional-properties: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServiceServiceIdentifier(ctx, serviceIdentifier, params)
	return err
}

// PostServiceServiceIdentifierCommand converts echo context to params.
func (w *ServerInterfaceWrapper) PostServiceServiceIdentifierCommand(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "service_identifier" -------------
	var serviceIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, ctx.Param("service_identifier"), &serviceIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostServiceServiceIdentifierCommand(ctx, serviceIdentifier)
	return err
}

// PostServiceServiceIdentifierEndpointPortNumberAvailability converts echo context to params.
func (w *ServerInterfaceWrapper) PostServiceServiceIdentifierEndpointPortNumberAvailability(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "service_identifier" -------------
	var serviceIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, ctx.Param("service_identifier"), &serviceIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_identifier: %s", err))
	}

	// ------------- Path parameter "port_number" -------------
	var portNumber int

	err = runtime.BindStyledParameterWithLocation("simple", false, "port_number", runtime.ParamLocationPath, ctx.Param("port_number"), &portNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter port_number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostServiceServiceIdentifierEndpointPortNumberAvailability(ctx, serviceIdentifier, portNumber)
	return err
}

// GetStarlark converts echo context to params.
func (w *ServerInterfaceWrapper) GetStarlark(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStarlark(ctx)
	return err
}

// PutStarlarkPackage converts echo context to params.
func (w *ServerInterfaceWrapper) PutStarlarkPackage(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutStarlarkPackage(ctx)
	return err
}

// PostStarlarkPackagePackageId converts echo context to params.
func (w *ServerInterfaceWrapper) PostStarlarkPackagePackageId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "package_id" -------------
	var packageId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "package_id", runtime.ParamLocationPath, ctx.Param("package_id"), &packageId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter package_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostStarlarkPackagePackageId(ctx, packageId)
	return err
}

// PostStarlarkScript converts echo context to params.
func (w *ServerInterfaceWrapper) PostStarlarkScript(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostStarlarkScript(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/artifact", wrapper.GetArtifact)
	router.PUT(baseURL+"/artifact/local-file", wrapper.PutArtifactLocalFile)
	router.PUT(baseURL+"/artifact/remote-file", wrapper.PutArtifactRemoteFile)
	router.PUT(baseURL+"/artifact/service/:service_identifier", wrapper.PutArtifactServiceServiceIdentifier)
	router.GET(baseURL+"/artifact/:artifact_identifier", wrapper.GetArtifactArtifactIdentifier)
	router.GET(baseURL+"/artifact/:artifact_identifier/download", wrapper.GetArtifactArtifactIdentifierDownload)
	router.GET(baseURL+"/service", wrapper.GetService)
	router.POST(baseURL+"/service/connection", wrapper.PostServiceConnection)
	router.GET(baseURL+"/service/:service_identifier", wrapper.GetServiceServiceIdentifier)
	router.POST(baseURL+"/service/:service_identifier/command", wrapper.PostServiceServiceIdentifierCommand)
	router.POST(baseURL+"/service/:service_identifier/endpoint/:port_number/availability", wrapper.PostServiceServiceIdentifierEndpointPortNumberAvailability)
	router.GET(baseURL+"/starlark", wrapper.GetStarlark)
	router.PUT(baseURL+"/starlark/package", wrapper.PutStarlarkPackage)
	router.POST(baseURL+"/starlark/package/:package_id", wrapper.PostStarlarkPackagePackageId)
	router.POST(baseURL+"/starlark/script", wrapper.PostStarlarkScript)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
