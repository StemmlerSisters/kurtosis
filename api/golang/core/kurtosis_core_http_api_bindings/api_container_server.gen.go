// Package kurtosis_core_http_api_bindings provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version (devel) DO NOT EDIT.
package kurtosis_core_http_api_bindings

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /artifacts)
	GetArtifacts(ctx echo.Context) error

	// (PUT /artifacts/local-file)
	PutArtifactsLocalFile(ctx echo.Context) error

	// (PUT /artifacts/remote-file)
	PutArtifactsRemoteFile(ctx echo.Context) error

	// (PUT /artifacts/services/{service_identifier})
	PutArtifactsServicesServiceIdentifier(ctx echo.Context, serviceIdentifier string) error

	// (GET /artifacts/{artifact_identifier})
	GetArtifactsArtifactIdentifier(ctx echo.Context, artifactIdentifier string) error

	// (GET /artifacts/{artifact_identifier}/download)
	GetArtifactsArtifactIdentifierDownload(ctx echo.Context, artifactIdentifier string) error

	// (GET /services)
	GetServices(ctx echo.Context) error

	// (POST /services/connection)
	PostServicesConnection(ctx echo.Context) error

	// (GET /services/{service_identifier})
	GetServicesServiceIdentifier(ctx echo.Context, serviceIdentifier string, params GetServicesServiceIdentifierParams) error

	// (POST /services/{service_identifier}/command)
	PostServicesServiceIdentifierCommand(ctx echo.Context, serviceIdentifier string) error

	// (POST /services/{service_identifier}/endpoints/{port_number}/availability)
	PostServicesServiceIdentifierEndpointsPortNumberAvailability(ctx echo.Context, serviceIdentifier string, portNumber int) error

	// (GET /starlark)
	GetStarlark(ctx echo.Context) error

	// (PUT /starlark/packages)
	PutStarlarkPackages(ctx echo.Context) error

	// (POST /starlark/packages/{package_id})
	PostStarlarkPackagesPackageId(ctx echo.Context, packageId string) error

	// (POST /starlark/scripts)
	PostStarlarkScripts(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetArtifacts converts echo context to params.
func (w *ServerInterfaceWrapper) GetArtifacts(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArtifacts(ctx)
	return err
}

// PutArtifactsLocalFile converts echo context to params.
func (w *ServerInterfaceWrapper) PutArtifactsLocalFile(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutArtifactsLocalFile(ctx)
	return err
}

// PutArtifactsRemoteFile converts echo context to params.
func (w *ServerInterfaceWrapper) PutArtifactsRemoteFile(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutArtifactsRemoteFile(ctx)
	return err
}

// PutArtifactsServicesServiceIdentifier converts echo context to params.
func (w *ServerInterfaceWrapper) PutArtifactsServicesServiceIdentifier(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "service_identifier" -------------
	var serviceIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, ctx.Param("service_identifier"), &serviceIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutArtifactsServicesServiceIdentifier(ctx, serviceIdentifier)
	return err
}

// GetArtifactsArtifactIdentifier converts echo context to params.
func (w *ServerInterfaceWrapper) GetArtifactsArtifactIdentifier(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "artifact_identifier" -------------
	var artifactIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "artifact_identifier", runtime.ParamLocationPath, ctx.Param("artifact_identifier"), &artifactIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter artifact_identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArtifactsArtifactIdentifier(ctx, artifactIdentifier)
	return err
}

// GetArtifactsArtifactIdentifierDownload converts echo context to params.
func (w *ServerInterfaceWrapper) GetArtifactsArtifactIdentifierDownload(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "artifact_identifier" -------------
	var artifactIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "artifact_identifier", runtime.ParamLocationPath, ctx.Param("artifact_identifier"), &artifactIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter artifact_identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArtifactsArtifactIdentifierDownload(ctx, artifactIdentifier)
	return err
}

// GetServices converts echo context to params.
func (w *ServerInterfaceWrapper) GetServices(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServices(ctx)
	return err
}

// PostServicesConnection converts echo context to params.
func (w *ServerInterfaceWrapper) PostServicesConnection(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostServicesConnection(ctx)
	return err
}

// GetServicesServiceIdentifier converts echo context to params.
func (w *ServerInterfaceWrapper) GetServicesServiceIdentifier(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "service_identifier" -------------
	var serviceIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, ctx.Param("service_identifier"), &serviceIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_identifier: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetServicesServiceIdentifierParams
	// ------------- Optional query parameter "additional-properties" -------------

	err = runtime.BindQueryParameter("form", true, false, "additional-properties", ctx.QueryParams(), &params.AdditionalProperties)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter additional-properties: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServicesServiceIdentifier(ctx, serviceIdentifier, params)
	return err
}

// PostServicesServiceIdentifierCommand converts echo context to params.
func (w *ServerInterfaceWrapper) PostServicesServiceIdentifierCommand(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "service_identifier" -------------
	var serviceIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, ctx.Param("service_identifier"), &serviceIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostServicesServiceIdentifierCommand(ctx, serviceIdentifier)
	return err
}

// PostServicesServiceIdentifierEndpointsPortNumberAvailability converts echo context to params.
func (w *ServerInterfaceWrapper) PostServicesServiceIdentifierEndpointsPortNumberAvailability(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "service_identifier" -------------
	var serviceIdentifier string

	err = runtime.BindStyledParameterWithLocation("simple", false, "service_identifier", runtime.ParamLocationPath, ctx.Param("service_identifier"), &serviceIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_identifier: %s", err))
	}

	// ------------- Path parameter "port_number" -------------
	var portNumber int

	err = runtime.BindStyledParameterWithLocation("simple", false, "port_number", runtime.ParamLocationPath, ctx.Param("port_number"), &portNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter port_number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostServicesServiceIdentifierEndpointsPortNumberAvailability(ctx, serviceIdentifier, portNumber)
	return err
}

// GetStarlark converts echo context to params.
func (w *ServerInterfaceWrapper) GetStarlark(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStarlark(ctx)
	return err
}

// PutStarlarkPackages converts echo context to params.
func (w *ServerInterfaceWrapper) PutStarlarkPackages(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutStarlarkPackages(ctx)
	return err
}

// PostStarlarkPackagesPackageId converts echo context to params.
func (w *ServerInterfaceWrapper) PostStarlarkPackagesPackageId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "package_id" -------------
	var packageId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "package_id", runtime.ParamLocationPath, ctx.Param("package_id"), &packageId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter package_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostStarlarkPackagesPackageId(ctx, packageId)
	return err
}

// PostStarlarkScripts converts echo context to params.
func (w *ServerInterfaceWrapper) PostStarlarkScripts(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostStarlarkScripts(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/artifacts", wrapper.GetArtifacts)
	router.PUT(baseURL+"/artifacts/local-file", wrapper.PutArtifactsLocalFile)
	router.PUT(baseURL+"/artifacts/remote-file", wrapper.PutArtifactsRemoteFile)
	router.PUT(baseURL+"/artifacts/services/:service_identifier", wrapper.PutArtifactsServicesServiceIdentifier)
	router.GET(baseURL+"/artifacts/:artifact_identifier", wrapper.GetArtifactsArtifactIdentifier)
	router.GET(baseURL+"/artifacts/:artifact_identifier/download", wrapper.GetArtifactsArtifactIdentifierDownload)
	router.GET(baseURL+"/services", wrapper.GetServices)
	router.POST(baseURL+"/services/connection", wrapper.PostServicesConnection)
	router.GET(baseURL+"/services/:service_identifier", wrapper.GetServicesServiceIdentifier)
	router.POST(baseURL+"/services/:service_identifier/command", wrapper.PostServicesServiceIdentifierCommand)
	router.POST(baseURL+"/services/:service_identifier/endpoints/:port_number/availability", wrapper.PostServicesServiceIdentifierEndpointsPortNumberAvailability)
	router.GET(baseURL+"/starlark", wrapper.GetStarlark)
	router.PUT(baseURL+"/starlark/packages", wrapper.PutStarlarkPackages)
	router.POST(baseURL+"/starlark/packages/:package_id", wrapper.PostStarlarkPackagesPackageId)
	router.POST(baseURL+"/starlark/scripts", wrapper.PostStarlarkScripts)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Gk+yfueyeHz8vwAAAP//MYxsmN1LAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
