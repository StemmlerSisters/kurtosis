// Code generated by mockery v2.16.0. DO NOT EDIT.

package backend_interface

import (
	context "context"

	api_container "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/api_container"

	enclave "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/enclave"

	engine "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/engine"

	exec_result "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/exec_result"

	io "io"

	logs_collector "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/logs_collector"

	logs_database "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/logs_database"

	mock "github.com/stretchr/testify/mock"

	net "net"

	networking_sidecar "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/networking_sidecar"

	service "github.com/kurtosis-tech/kurtosis/container-engine-lib/lib/backend_interface/objects/service"
)

// MockKurtosisBackend is an autogenerated mock type for the KurtosisBackend type
type MockKurtosisBackend struct {
	mock.Mock
}

type MockKurtosisBackend_Expecter struct {
	mock *mock.Mock
}

func (_m *MockKurtosisBackend) EXPECT() *MockKurtosisBackend_Expecter {
	return &MockKurtosisBackend_Expecter{mock: &_m.Mock}
}

// CopyFilesFromUserService provides a mock function with given fields: ctx, enclaveId, serviceGuid, srcPathOnService, output
func (_m *MockKurtosisBackend) CopyFilesFromUserService(ctx context.Context, enclaveId enclave.EnclaveID, serviceGuid service.ServiceGUID, srcPathOnService string, output io.Writer) error {
	ret := _m.Called(ctx, enclaveId, serviceGuid, srcPathOnService, output)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, service.ServiceGUID, string, io.Writer) error); ok {
		r0 = rf(ctx, enclaveId, serviceGuid, srcPathOnService, output)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_CopyFilesFromUserService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyFilesFromUserService'
type MockKurtosisBackend_CopyFilesFromUserService_Call struct {
	*mock.Call
}

// CopyFilesFromUserService is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - serviceGuid service.ServiceGUID
//   - srcPathOnService string
//   - output io.Writer
func (_e *MockKurtosisBackend_Expecter) CopyFilesFromUserService(ctx interface{}, enclaveId interface{}, serviceGuid interface{}, srcPathOnService interface{}, output interface{}) *MockKurtosisBackend_CopyFilesFromUserService_Call {
	return &MockKurtosisBackend_CopyFilesFromUserService_Call{Call: _e.mock.On("CopyFilesFromUserService", ctx, enclaveId, serviceGuid, srcPathOnService, output)}
}

func (_c *MockKurtosisBackend_CopyFilesFromUserService_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, serviceGuid service.ServiceGUID, srcPathOnService string, output io.Writer)) *MockKurtosisBackend_CopyFilesFromUserService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(service.ServiceGUID), args[3].(string), args[4].(io.Writer))
	})
	return _c
}

func (_c *MockKurtosisBackend_CopyFilesFromUserService_Call) Return(_a0 error) *MockKurtosisBackend_CopyFilesFromUserService_Call {
	_c.Call.Return(_a0)
	return _c
}

// CreateAPIContainer provides a mock function with given fields: ctx, image, enclaveId, grpcPortNum, grpcProxyPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars
func (_m *MockKurtosisBackend) CreateAPIContainer(ctx context.Context, image string, enclaveId enclave.EnclaveID, grpcPortNum uint16, grpcProxyPortNum uint16, enclaveDataVolumeDirpath string, ownIpAddressEnvVar string, customEnvVars map[string]string) (*api_container.APIContainer, error) {
	ret := _m.Called(ctx, image, enclaveId, grpcPortNum, grpcProxyPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)

	var r0 *api_container.APIContainer
	if rf, ok := ret.Get(0).(func(context.Context, string, enclave.EnclaveID, uint16, uint16, string, string, map[string]string) *api_container.APIContainer); ok {
		r0 = rf(ctx, image, enclaveId, grpcPortNum, grpcProxyPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api_container.APIContainer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, enclave.EnclaveID, uint16, uint16, string, string, map[string]string) error); ok {
		r1 = rf(ctx, image, enclaveId, grpcPortNum, grpcProxyPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_CreateAPIContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAPIContainer'
type MockKurtosisBackend_CreateAPIContainer_Call struct {
	*mock.Call
}

// CreateAPIContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - image string
//   - enclaveId enclave.EnclaveID
//   - grpcPortNum uint16
//   - grpcProxyPortNum uint16
//   - enclaveDataVolumeDirpath string
//   - ownIpAddressEnvVar string
//   - customEnvVars map[string]string
func (_e *MockKurtosisBackend_Expecter) CreateAPIContainer(ctx interface{}, image interface{}, enclaveId interface{}, grpcPortNum interface{}, grpcProxyPortNum interface{}, enclaveDataVolumeDirpath interface{}, ownIpAddressEnvVar interface{}, customEnvVars interface{}) *MockKurtosisBackend_CreateAPIContainer_Call {
	return &MockKurtosisBackend_CreateAPIContainer_Call{Call: _e.mock.On("CreateAPIContainer", ctx, image, enclaveId, grpcPortNum, grpcProxyPortNum, enclaveDataVolumeDirpath, ownIpAddressEnvVar, customEnvVars)}
}

func (_c *MockKurtosisBackend_CreateAPIContainer_Call) Run(run func(ctx context.Context, image string, enclaveId enclave.EnclaveID, grpcPortNum uint16, grpcProxyPortNum uint16, enclaveDataVolumeDirpath string, ownIpAddressEnvVar string, customEnvVars map[string]string)) *MockKurtosisBackend_CreateAPIContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(enclave.EnclaveID), args[3].(uint16), args[4].(uint16), args[5].(string), args[6].(string), args[7].(map[string]string))
	})
	return _c
}

func (_c *MockKurtosisBackend_CreateAPIContainer_Call) Return(_a0 *api_container.APIContainer, _a1 error) *MockKurtosisBackend_CreateAPIContainer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CreateEnclave provides a mock function with given fields: ctx, enclaveId, isPartitioningEnabled
func (_m *MockKurtosisBackend) CreateEnclave(ctx context.Context, enclaveId enclave.EnclaveID, isPartitioningEnabled bool) (*enclave.Enclave, error) {
	ret := _m.Called(ctx, enclaveId, isPartitioningEnabled)

	var r0 *enclave.Enclave
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, bool) *enclave.Enclave); ok {
		r0 = rf(ctx, enclaveId, isPartitioningEnabled)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*enclave.Enclave)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, bool) error); ok {
		r1 = rf(ctx, enclaveId, isPartitioningEnabled)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_CreateEnclave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEnclave'
type MockKurtosisBackend_CreateEnclave_Call struct {
	*mock.Call
}

// CreateEnclave is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - isPartitioningEnabled bool
func (_e *MockKurtosisBackend_Expecter) CreateEnclave(ctx interface{}, enclaveId interface{}, isPartitioningEnabled interface{}) *MockKurtosisBackend_CreateEnclave_Call {
	return &MockKurtosisBackend_CreateEnclave_Call{Call: _e.mock.On("CreateEnclave", ctx, enclaveId, isPartitioningEnabled)}
}

func (_c *MockKurtosisBackend_CreateEnclave_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, isPartitioningEnabled bool)) *MockKurtosisBackend_CreateEnclave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(bool))
	})
	return _c
}

func (_c *MockKurtosisBackend_CreateEnclave_Call) Return(_a0 *enclave.Enclave, _a1 error) *MockKurtosisBackend_CreateEnclave_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CreateEngine provides a mock function with given fields: ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, grpcProxyPortNum, envVars
func (_m *MockKurtosisBackend) CreateEngine(ctx context.Context, imageOrgAndRepo string, imageVersionTag string, grpcPortNum uint16, grpcProxyPortNum uint16, envVars map[string]string) (*engine.Engine, error) {
	ret := _m.Called(ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, grpcProxyPortNum, envVars)

	var r0 *engine.Engine
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint16, uint16, map[string]string) *engine.Engine); ok {
		r0 = rf(ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, grpcProxyPortNum, envVars)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*engine.Engine)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, uint16, uint16, map[string]string) error); ok {
		r1 = rf(ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, grpcProxyPortNum, envVars)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_CreateEngine_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEngine'
type MockKurtosisBackend_CreateEngine_Call struct {
	*mock.Call
}

// CreateEngine is a helper method to define mock.On call
//   - ctx context.Context
//   - imageOrgAndRepo string
//   - imageVersionTag string
//   - grpcPortNum uint16
//   - grpcProxyPortNum uint16
//   - envVars map[string]string
func (_e *MockKurtosisBackend_Expecter) CreateEngine(ctx interface{}, imageOrgAndRepo interface{}, imageVersionTag interface{}, grpcPortNum interface{}, grpcProxyPortNum interface{}, envVars interface{}) *MockKurtosisBackend_CreateEngine_Call {
	return &MockKurtosisBackend_CreateEngine_Call{Call: _e.mock.On("CreateEngine", ctx, imageOrgAndRepo, imageVersionTag, grpcPortNum, grpcProxyPortNum, envVars)}
}

func (_c *MockKurtosisBackend_CreateEngine_Call) Run(run func(ctx context.Context, imageOrgAndRepo string, imageVersionTag string, grpcPortNum uint16, grpcProxyPortNum uint16, envVars map[string]string)) *MockKurtosisBackend_CreateEngine_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(uint16), args[4].(uint16), args[5].(map[string]string))
	})
	return _c
}

func (_c *MockKurtosisBackend_CreateEngine_Call) Return(_a0 *engine.Engine, _a1 error) *MockKurtosisBackend_CreateEngine_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CreateLogsCollector provides a mock function with given fields: ctx, logsCollectorTcpPortNumber, logsCollectorHttpPortNumber
func (_m *MockKurtosisBackend) CreateLogsCollector(ctx context.Context, logsCollectorTcpPortNumber uint16, logsCollectorHttpPortNumber uint16) (*logs_collector.LogsCollector, error) {
	ret := _m.Called(ctx, logsCollectorTcpPortNumber, logsCollectorHttpPortNumber)

	var r0 *logs_collector.LogsCollector
	if rf, ok := ret.Get(0).(func(context.Context, uint16, uint16) *logs_collector.LogsCollector); ok {
		r0 = rf(ctx, logsCollectorTcpPortNumber, logsCollectorHttpPortNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_collector.LogsCollector)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint16, uint16) error); ok {
		r1 = rf(ctx, logsCollectorTcpPortNumber, logsCollectorHttpPortNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_CreateLogsCollector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLogsCollector'
type MockKurtosisBackend_CreateLogsCollector_Call struct {
	*mock.Call
}

// CreateLogsCollector is a helper method to define mock.On call
//   - ctx context.Context
//   - logsCollectorTcpPortNumber uint16
//   - logsCollectorHttpPortNumber uint16
func (_e *MockKurtosisBackend_Expecter) CreateLogsCollector(ctx interface{}, logsCollectorTcpPortNumber interface{}, logsCollectorHttpPortNumber interface{}) *MockKurtosisBackend_CreateLogsCollector_Call {
	return &MockKurtosisBackend_CreateLogsCollector_Call{Call: _e.mock.On("CreateLogsCollector", ctx, logsCollectorTcpPortNumber, logsCollectorHttpPortNumber)}
}

func (_c *MockKurtosisBackend_CreateLogsCollector_Call) Run(run func(ctx context.Context, logsCollectorTcpPortNumber uint16, logsCollectorHttpPortNumber uint16)) *MockKurtosisBackend_CreateLogsCollector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint16), args[2].(uint16))
	})
	return _c
}

func (_c *MockKurtosisBackend_CreateLogsCollector_Call) Return(_a0 *logs_collector.LogsCollector, _a1 error) *MockKurtosisBackend_CreateLogsCollector_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CreateLogsDatabase provides a mock function with given fields: ctx, logsDatabaseHttpPortNumber
func (_m *MockKurtosisBackend) CreateLogsDatabase(ctx context.Context, logsDatabaseHttpPortNumber uint16) (*logs_database.LogsDatabase, error) {
	ret := _m.Called(ctx, logsDatabaseHttpPortNumber)

	var r0 *logs_database.LogsDatabase
	if rf, ok := ret.Get(0).(func(context.Context, uint16) *logs_database.LogsDatabase); ok {
		r0 = rf(ctx, logsDatabaseHttpPortNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_database.LogsDatabase)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint16) error); ok {
		r1 = rf(ctx, logsDatabaseHttpPortNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_CreateLogsDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLogsDatabase'
type MockKurtosisBackend_CreateLogsDatabase_Call struct {
	*mock.Call
}

// CreateLogsDatabase is a helper method to define mock.On call
//   - ctx context.Context
//   - logsDatabaseHttpPortNumber uint16
func (_e *MockKurtosisBackend_Expecter) CreateLogsDatabase(ctx interface{}, logsDatabaseHttpPortNumber interface{}) *MockKurtosisBackend_CreateLogsDatabase_Call {
	return &MockKurtosisBackend_CreateLogsDatabase_Call{Call: _e.mock.On("CreateLogsDatabase", ctx, logsDatabaseHttpPortNumber)}
}

func (_c *MockKurtosisBackend_CreateLogsDatabase_Call) Run(run func(ctx context.Context, logsDatabaseHttpPortNumber uint16)) *MockKurtosisBackend_CreateLogsDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint16))
	})
	return _c
}

func (_c *MockKurtosisBackend_CreateLogsDatabase_Call) Return(_a0 *logs_database.LogsDatabase, _a1 error) *MockKurtosisBackend_CreateLogsDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// CreateNetworkingSidecar provides a mock function with given fields: ctx, enclaveId, serviceGuid
func (_m *MockKurtosisBackend) CreateNetworkingSidecar(ctx context.Context, enclaveId enclave.EnclaveID, serviceGuid service.ServiceGUID) (*networking_sidecar.NetworkingSidecar, error) {
	ret := _m.Called(ctx, enclaveId, serviceGuid)

	var r0 *networking_sidecar.NetworkingSidecar
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, service.ServiceGUID) *networking_sidecar.NetworkingSidecar); ok {
		r0 = rf(ctx, enclaveId, serviceGuid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networking_sidecar.NetworkingSidecar)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, service.ServiceGUID) error); ok {
		r1 = rf(ctx, enclaveId, serviceGuid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_CreateNetworkingSidecar_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNetworkingSidecar'
type MockKurtosisBackend_CreateNetworkingSidecar_Call struct {
	*mock.Call
}

// CreateNetworkingSidecar is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - serviceGuid service.ServiceGUID
func (_e *MockKurtosisBackend_Expecter) CreateNetworkingSidecar(ctx interface{}, enclaveId interface{}, serviceGuid interface{}) *MockKurtosisBackend_CreateNetworkingSidecar_Call {
	return &MockKurtosisBackend_CreateNetworkingSidecar_Call{Call: _e.mock.On("CreateNetworkingSidecar", ctx, enclaveId, serviceGuid)}
}

func (_c *MockKurtosisBackend_CreateNetworkingSidecar_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, serviceGuid service.ServiceGUID)) *MockKurtosisBackend_CreateNetworkingSidecar_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(service.ServiceGUID))
	})
	return _c
}

func (_c *MockKurtosisBackend_CreateNetworkingSidecar_Call) Return(_a0 *networking_sidecar.NetworkingSidecar, _a1 error) *MockKurtosisBackend_CreateNetworkingSidecar_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// DestroyAPIContainers provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) DestroyAPIContainers(ctx context.Context, filters *api_container.APIContainerFilters) (map[enclave.EnclaveID]bool, map[enclave.EnclaveID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveID]bool
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveID]bool)
		}
	}

	var r1 map[enclave.EnclaveID]error
	if rf, ok := ret.Get(1).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *api_container.APIContainerFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_DestroyAPIContainers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyAPIContainers'
type MockKurtosisBackend_DestroyAPIContainers_Call struct {
	*mock.Call
}

// DestroyAPIContainers is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *api_container.APIContainerFilters
func (_e *MockKurtosisBackend_Expecter) DestroyAPIContainers(ctx interface{}, filters interface{}) *MockKurtosisBackend_DestroyAPIContainers_Call {
	return &MockKurtosisBackend_DestroyAPIContainers_Call{Call: _e.mock.On("DestroyAPIContainers", ctx, filters)}
}

func (_c *MockKurtosisBackend_DestroyAPIContainers_Call) Run(run func(ctx context.Context, filters *api_container.APIContainerFilters)) *MockKurtosisBackend_DestroyAPIContainers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*api_container.APIContainerFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyAPIContainers_Call) Return(successfulApiContainerIds map[enclave.EnclaveID]bool, erroredApiContainerIds map[enclave.EnclaveID]error, resultErr error) *MockKurtosisBackend_DestroyAPIContainers_Call {
	_c.Call.Return(successfulApiContainerIds, erroredApiContainerIds, resultErr)
	return _c
}

// DestroyEnclaves provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) DestroyEnclaves(ctx context.Context, filters *enclave.EnclaveFilters) (map[enclave.EnclaveID]bool, map[enclave.EnclaveID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveID]bool
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveID]bool)
		}
	}

	var r1 map[enclave.EnclaveID]error
	if rf, ok := ret.Get(1).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *enclave.EnclaveFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_DestroyEnclaves_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyEnclaves'
type MockKurtosisBackend_DestroyEnclaves_Call struct {
	*mock.Call
}

// DestroyEnclaves is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *enclave.EnclaveFilters
func (_e *MockKurtosisBackend_Expecter) DestroyEnclaves(ctx interface{}, filters interface{}) *MockKurtosisBackend_DestroyEnclaves_Call {
	return &MockKurtosisBackend_DestroyEnclaves_Call{Call: _e.mock.On("DestroyEnclaves", ctx, filters)}
}

func (_c *MockKurtosisBackend_DestroyEnclaves_Call) Run(run func(ctx context.Context, filters *enclave.EnclaveFilters)) *MockKurtosisBackend_DestroyEnclaves_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*enclave.EnclaveFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyEnclaves_Call) Return(successfulEnclaveIds map[enclave.EnclaveID]bool, erroredEnclaveIds map[enclave.EnclaveID]error, resultErr error) *MockKurtosisBackend_DestroyEnclaves_Call {
	_c.Call.Return(successfulEnclaveIds, erroredEnclaveIds, resultErr)
	return _c
}

// DestroyEngines provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) DestroyEngines(ctx context.Context, filters *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[engine.EngineGUID]bool
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[engine.EngineGUID]bool)
		}
	}

	var r1 map[engine.EngineGUID]error
	if rf, ok := ret.Get(1).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[engine.EngineGUID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *engine.EngineFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_DestroyEngines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyEngines'
type MockKurtosisBackend_DestroyEngines_Call struct {
	*mock.Call
}

// DestroyEngines is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *engine.EngineFilters
func (_e *MockKurtosisBackend_Expecter) DestroyEngines(ctx interface{}, filters interface{}) *MockKurtosisBackend_DestroyEngines_Call {
	return &MockKurtosisBackend_DestroyEngines_Call{Call: _e.mock.On("DestroyEngines", ctx, filters)}
}

func (_c *MockKurtosisBackend_DestroyEngines_Call) Run(run func(ctx context.Context, filters *engine.EngineFilters)) *MockKurtosisBackend_DestroyEngines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*engine.EngineFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyEngines_Call) Return(successfulEngineGuids map[engine.EngineGUID]bool, erroredEngineGuids map[engine.EngineGUID]error, resultErr error) *MockKurtosisBackend_DestroyEngines_Call {
	_c.Call.Return(successfulEngineGuids, erroredEngineGuids, resultErr)
	return _c
}

// DestroyLogsCollector provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) DestroyLogsCollector(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_DestroyLogsCollector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyLogsCollector'
type MockKurtosisBackend_DestroyLogsCollector_Call struct {
	*mock.Call
}

// DestroyLogsCollector is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockKurtosisBackend_Expecter) DestroyLogsCollector(ctx interface{}) *MockKurtosisBackend_DestroyLogsCollector_Call {
	return &MockKurtosisBackend_DestroyLogsCollector_Call{Call: _e.mock.On("DestroyLogsCollector", ctx)}
}

func (_c *MockKurtosisBackend_DestroyLogsCollector_Call) Run(run func(ctx context.Context)) *MockKurtosisBackend_DestroyLogsCollector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyLogsCollector_Call) Return(_a0 error) *MockKurtosisBackend_DestroyLogsCollector_Call {
	_c.Call.Return(_a0)
	return _c
}

// DestroyLogsDatabase provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) DestroyLogsDatabase(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_DestroyLogsDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyLogsDatabase'
type MockKurtosisBackend_DestroyLogsDatabase_Call struct {
	*mock.Call
}

// DestroyLogsDatabase is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockKurtosisBackend_Expecter) DestroyLogsDatabase(ctx interface{}) *MockKurtosisBackend_DestroyLogsDatabase_Call {
	return &MockKurtosisBackend_DestroyLogsDatabase_Call{Call: _e.mock.On("DestroyLogsDatabase", ctx)}
}

func (_c *MockKurtosisBackend_DestroyLogsDatabase_Call) Run(run func(ctx context.Context)) *MockKurtosisBackend_DestroyLogsDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyLogsDatabase_Call) Return(_a0 error) *MockKurtosisBackend_DestroyLogsDatabase_Call {
	_c.Call.Return(_a0)
	return _c
}

// DestroyNetworkingSidecars provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) DestroyNetworkingSidecars(ctx context.Context, filters *networking_sidecar.NetworkingSidecarFilters) (map[service.ServiceGUID]bool, map[service.ServiceGUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[service.ServiceGUID]bool
	if rf, ok := ret.Get(0).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) map[service.ServiceGUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceGUID]bool)
		}
	}

	var r1 map[service.ServiceGUID]error
	if rf, ok := ret.Get(1).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) map[service.ServiceGUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceGUID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_DestroyNetworkingSidecars_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyNetworkingSidecars'
type MockKurtosisBackend_DestroyNetworkingSidecars_Call struct {
	*mock.Call
}

// DestroyNetworkingSidecars is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *networking_sidecar.NetworkingSidecarFilters
func (_e *MockKurtosisBackend_Expecter) DestroyNetworkingSidecars(ctx interface{}, filters interface{}) *MockKurtosisBackend_DestroyNetworkingSidecars_Call {
	return &MockKurtosisBackend_DestroyNetworkingSidecars_Call{Call: _e.mock.On("DestroyNetworkingSidecars", ctx, filters)}
}

func (_c *MockKurtosisBackend_DestroyNetworkingSidecars_Call) Run(run func(ctx context.Context, filters *networking_sidecar.NetworkingSidecarFilters)) *MockKurtosisBackend_DestroyNetworkingSidecars_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*networking_sidecar.NetworkingSidecarFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyNetworkingSidecars_Call) Return(successfulUserServiceGuids map[service.ServiceGUID]bool, erroredUserServiceGuids map[service.ServiceGUID]error, resultErr error) *MockKurtosisBackend_DestroyNetworkingSidecars_Call {
	_c.Call.Return(successfulUserServiceGuids, erroredUserServiceGuids, resultErr)
	return _c
}

// DestroyUserServices provides a mock function with given fields: ctx, enclaveId, filters
func (_m *MockKurtosisBackend) DestroyUserServices(ctx context.Context, enclaveId enclave.EnclaveID, filters *service.ServiceFilters) (map[service.ServiceGUID]bool, map[service.ServiceGUID]error, error) {
	ret := _m.Called(ctx, enclaveId, filters)

	var r0 map[service.ServiceGUID]bool
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, *service.ServiceFilters) map[service.ServiceGUID]bool); ok {
		r0 = rf(ctx, enclaveId, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceGUID]bool)
		}
	}

	var r1 map[service.ServiceGUID]error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, *service.ServiceFilters) map[service.ServiceGUID]error); ok {
		r1 = rf(ctx, enclaveId, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceGUID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveID, *service.ServiceFilters) error); ok {
		r2 = rf(ctx, enclaveId, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_DestroyUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyUserServices'
type MockKurtosisBackend_DestroyUserServices_Call struct {
	*mock.Call
}

// DestroyUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - filters *service.ServiceFilters
func (_e *MockKurtosisBackend_Expecter) DestroyUserServices(ctx interface{}, enclaveId interface{}, filters interface{}) *MockKurtosisBackend_DestroyUserServices_Call {
	return &MockKurtosisBackend_DestroyUserServices_Call{Call: _e.mock.On("DestroyUserServices", ctx, enclaveId, filters)}
}

func (_c *MockKurtosisBackend_DestroyUserServices_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, filters *service.ServiceFilters)) *MockKurtosisBackend_DestroyUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(*service.ServiceFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_DestroyUserServices_Call) Return(successfulUserServiceGuids map[service.ServiceGUID]bool, erroredUserServiceGuids map[service.ServiceGUID]error, resultErr error) *MockKurtosisBackend_DestroyUserServices_Call {
	_c.Call.Return(successfulUserServiceGuids, erroredUserServiceGuids, resultErr)
	return _c
}

// DumpEnclave provides a mock function with given fields: ctx, enclaveId, outputDirpath
func (_m *MockKurtosisBackend) DumpEnclave(ctx context.Context, enclaveId enclave.EnclaveID, outputDirpath string) error {
	ret := _m.Called(ctx, enclaveId, outputDirpath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, string) error); ok {
		r0 = rf(ctx, enclaveId, outputDirpath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_DumpEnclave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DumpEnclave'
type MockKurtosisBackend_DumpEnclave_Call struct {
	*mock.Call
}

// DumpEnclave is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - outputDirpath string
func (_e *MockKurtosisBackend_Expecter) DumpEnclave(ctx interface{}, enclaveId interface{}, outputDirpath interface{}) *MockKurtosisBackend_DumpEnclave_Call {
	return &MockKurtosisBackend_DumpEnclave_Call{Call: _e.mock.On("DumpEnclave", ctx, enclaveId, outputDirpath)}
}

func (_c *MockKurtosisBackend_DumpEnclave_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, outputDirpath string)) *MockKurtosisBackend_DumpEnclave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(string))
	})
	return _c
}

func (_c *MockKurtosisBackend_DumpEnclave_Call) Return(_a0 error) *MockKurtosisBackend_DumpEnclave_Call {
	_c.Call.Return(_a0)
	return _c
}

// FetchImage provides a mock function with given fields: ctx, image
func (_m *MockKurtosisBackend) FetchImage(ctx context.Context, image string) error {
	ret := _m.Called(ctx, image)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, image)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_FetchImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchImage'
type MockKurtosisBackend_FetchImage_Call struct {
	*mock.Call
}

// FetchImage is a helper method to define mock.On call
//   - ctx context.Context
//   - image string
func (_e *MockKurtosisBackend_Expecter) FetchImage(ctx interface{}, image interface{}) *MockKurtosisBackend_FetchImage_Call {
	return &MockKurtosisBackend_FetchImage_Call{Call: _e.mock.On("FetchImage", ctx, image)}
}

func (_c *MockKurtosisBackend_FetchImage_Call) Run(run func(ctx context.Context, image string)) *MockKurtosisBackend_FetchImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockKurtosisBackend_FetchImage_Call) Return(_a0 error) *MockKurtosisBackend_FetchImage_Call {
	_c.Call.Return(_a0)
	return _c
}

// GetAPIContainers provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) GetAPIContainers(ctx context.Context, filters *api_container.APIContainerFilters) (map[enclave.EnclaveID]*api_container.APIContainer, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveID]*api_container.APIContainer
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveID]*api_container.APIContainer); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveID]*api_container.APIContainer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *api_container.APIContainerFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetAPIContainers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAPIContainers'
type MockKurtosisBackend_GetAPIContainers_Call struct {
	*mock.Call
}

// GetAPIContainers is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *api_container.APIContainerFilters
func (_e *MockKurtosisBackend_Expecter) GetAPIContainers(ctx interface{}, filters interface{}) *MockKurtosisBackend_GetAPIContainers_Call {
	return &MockKurtosisBackend_GetAPIContainers_Call{Call: _e.mock.On("GetAPIContainers", ctx, filters)}
}

func (_c *MockKurtosisBackend_GetAPIContainers_Call) Run(run func(ctx context.Context, filters *api_container.APIContainerFilters)) *MockKurtosisBackend_GetAPIContainers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*api_container.APIContainerFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetAPIContainers_Call) Return(_a0 map[enclave.EnclaveID]*api_container.APIContainer, _a1 error) *MockKurtosisBackend_GetAPIContainers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// GetConnectionWithUserService provides a mock function with given fields: ctx, enclaveId, serviceGuid
func (_m *MockKurtosisBackend) GetConnectionWithUserService(ctx context.Context, enclaveId enclave.EnclaveID, serviceGuid service.ServiceGUID) (net.Conn, error) {
	ret := _m.Called(ctx, enclaveId, serviceGuid)

	var r0 net.Conn
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, service.ServiceGUID) net.Conn); ok {
		r0 = rf(ctx, enclaveId, serviceGuid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(net.Conn)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, service.ServiceGUID) error); ok {
		r1 = rf(ctx, enclaveId, serviceGuid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetConnectionWithUserService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConnectionWithUserService'
type MockKurtosisBackend_GetConnectionWithUserService_Call struct {
	*mock.Call
}

// GetConnectionWithUserService is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - serviceGuid service.ServiceGUID
func (_e *MockKurtosisBackend_Expecter) GetConnectionWithUserService(ctx interface{}, enclaveId interface{}, serviceGuid interface{}) *MockKurtosisBackend_GetConnectionWithUserService_Call {
	return &MockKurtosisBackend_GetConnectionWithUserService_Call{Call: _e.mock.On("GetConnectionWithUserService", ctx, enclaveId, serviceGuid)}
}

func (_c *MockKurtosisBackend_GetConnectionWithUserService_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, serviceGuid service.ServiceGUID)) *MockKurtosisBackend_GetConnectionWithUserService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(service.ServiceGUID))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetConnectionWithUserService_Call) Return(resultConn net.Conn, resultErr error) *MockKurtosisBackend_GetConnectionWithUserService_Call {
	_c.Call.Return(resultConn, resultErr)
	return _c
}

// GetEnclaves provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) GetEnclaves(ctx context.Context, filters *enclave.EnclaveFilters) (map[enclave.EnclaveID]*enclave.Enclave, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveID]*enclave.Enclave
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveID]*enclave.Enclave); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveID]*enclave.Enclave)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *enclave.EnclaveFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetEnclaves_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEnclaves'
type MockKurtosisBackend_GetEnclaves_Call struct {
	*mock.Call
}

// GetEnclaves is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *enclave.EnclaveFilters
func (_e *MockKurtosisBackend_Expecter) GetEnclaves(ctx interface{}, filters interface{}) *MockKurtosisBackend_GetEnclaves_Call {
	return &MockKurtosisBackend_GetEnclaves_Call{Call: _e.mock.On("GetEnclaves", ctx, filters)}
}

func (_c *MockKurtosisBackend_GetEnclaves_Call) Run(run func(ctx context.Context, filters *enclave.EnclaveFilters)) *MockKurtosisBackend_GetEnclaves_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*enclave.EnclaveFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetEnclaves_Call) Return(_a0 map[enclave.EnclaveID]*enclave.Enclave, _a1 error) *MockKurtosisBackend_GetEnclaves_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// GetEngines provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) GetEngines(ctx context.Context, filters *engine.EngineFilters) (map[engine.EngineGUID]*engine.Engine, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[engine.EngineGUID]*engine.Engine
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]*engine.Engine); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[engine.EngineGUID]*engine.Engine)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *engine.EngineFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetEngines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEngines'
type MockKurtosisBackend_GetEngines_Call struct {
	*mock.Call
}

// GetEngines is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *engine.EngineFilters
func (_e *MockKurtosisBackend_Expecter) GetEngines(ctx interface{}, filters interface{}) *MockKurtosisBackend_GetEngines_Call {
	return &MockKurtosisBackend_GetEngines_Call{Call: _e.mock.On("GetEngines", ctx, filters)}
}

func (_c *MockKurtosisBackend_GetEngines_Call) Run(run func(ctx context.Context, filters *engine.EngineFilters)) *MockKurtosisBackend_GetEngines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*engine.EngineFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetEngines_Call) Return(_a0 map[engine.EngineGUID]*engine.Engine, _a1 error) *MockKurtosisBackend_GetEngines_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// GetLogsCollector provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) GetLogsCollector(ctx context.Context) (*logs_collector.LogsCollector, error) {
	ret := _m.Called(ctx)

	var r0 *logs_collector.LogsCollector
	if rf, ok := ret.Get(0).(func(context.Context) *logs_collector.LogsCollector); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_collector.LogsCollector)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetLogsCollector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogsCollector'
type MockKurtosisBackend_GetLogsCollector_Call struct {
	*mock.Call
}

// GetLogsCollector is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockKurtosisBackend_Expecter) GetLogsCollector(ctx interface{}) *MockKurtosisBackend_GetLogsCollector_Call {
	return &MockKurtosisBackend_GetLogsCollector_Call{Call: _e.mock.On("GetLogsCollector", ctx)}
}

func (_c *MockKurtosisBackend_GetLogsCollector_Call) Run(run func(ctx context.Context)) *MockKurtosisBackend_GetLogsCollector_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetLogsCollector_Call) Return(_a0 *logs_collector.LogsCollector, _a1 error) *MockKurtosisBackend_GetLogsCollector_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// GetLogsDatabase provides a mock function with given fields: ctx
func (_m *MockKurtosisBackend) GetLogsDatabase(ctx context.Context) (*logs_database.LogsDatabase, error) {
	ret := _m.Called(ctx)

	var r0 *logs_database.LogsDatabase
	if rf, ok := ret.Get(0).(func(context.Context) *logs_database.LogsDatabase); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*logs_database.LogsDatabase)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetLogsDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogsDatabase'
type MockKurtosisBackend_GetLogsDatabase_Call struct {
	*mock.Call
}

// GetLogsDatabase is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockKurtosisBackend_Expecter) GetLogsDatabase(ctx interface{}) *MockKurtosisBackend_GetLogsDatabase_Call {
	return &MockKurtosisBackend_GetLogsDatabase_Call{Call: _e.mock.On("GetLogsDatabase", ctx)}
}

func (_c *MockKurtosisBackend_GetLogsDatabase_Call) Run(run func(ctx context.Context)) *MockKurtosisBackend_GetLogsDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetLogsDatabase_Call) Return(_a0 *logs_database.LogsDatabase, _a1 error) *MockKurtosisBackend_GetLogsDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// GetNetworkingSidecars provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) GetNetworkingSidecars(ctx context.Context, filters *networking_sidecar.NetworkingSidecarFilters) (map[service.ServiceGUID]*networking_sidecar.NetworkingSidecar, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[service.ServiceGUID]*networking_sidecar.NetworkingSidecar
	if rf, ok := ret.Get(0).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) map[service.ServiceGUID]*networking_sidecar.NetworkingSidecar); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceGUID]*networking_sidecar.NetworkingSidecar)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) error); ok {
		r1 = rf(ctx, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetNetworkingSidecars_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNetworkingSidecars'
type MockKurtosisBackend_GetNetworkingSidecars_Call struct {
	*mock.Call
}

// GetNetworkingSidecars is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *networking_sidecar.NetworkingSidecarFilters
func (_e *MockKurtosisBackend_Expecter) GetNetworkingSidecars(ctx interface{}, filters interface{}) *MockKurtosisBackend_GetNetworkingSidecars_Call {
	return &MockKurtosisBackend_GetNetworkingSidecars_Call{Call: _e.mock.On("GetNetworkingSidecars", ctx, filters)}
}

func (_c *MockKurtosisBackend_GetNetworkingSidecars_Call) Run(run func(ctx context.Context, filters *networking_sidecar.NetworkingSidecarFilters)) *MockKurtosisBackend_GetNetworkingSidecars_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*networking_sidecar.NetworkingSidecarFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetNetworkingSidecars_Call) Return(_a0 map[service.ServiceGUID]*networking_sidecar.NetworkingSidecar, _a1 error) *MockKurtosisBackend_GetNetworkingSidecars_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// GetUserServiceLogs provides a mock function with given fields: ctx, enclaveId, filters, shouldFollowLogs
func (_m *MockKurtosisBackend) GetUserServiceLogs(ctx context.Context, enclaveId enclave.EnclaveID, filters *service.ServiceFilters, shouldFollowLogs bool) (map[service.ServiceGUID]io.ReadCloser, map[service.ServiceGUID]error, error) {
	ret := _m.Called(ctx, enclaveId, filters, shouldFollowLogs)

	var r0 map[service.ServiceGUID]io.ReadCloser
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, *service.ServiceFilters, bool) map[service.ServiceGUID]io.ReadCloser); ok {
		r0 = rf(ctx, enclaveId, filters, shouldFollowLogs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceGUID]io.ReadCloser)
		}
	}

	var r1 map[service.ServiceGUID]error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, *service.ServiceFilters, bool) map[service.ServiceGUID]error); ok {
		r1 = rf(ctx, enclaveId, filters, shouldFollowLogs)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceGUID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveID, *service.ServiceFilters, bool) error); ok {
		r2 = rf(ctx, enclaveId, filters, shouldFollowLogs)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_GetUserServiceLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserServiceLogs'
type MockKurtosisBackend_GetUserServiceLogs_Call struct {
	*mock.Call
}

// GetUserServiceLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - filters *service.ServiceFilters
//   - shouldFollowLogs bool
func (_e *MockKurtosisBackend_Expecter) GetUserServiceLogs(ctx interface{}, enclaveId interface{}, filters interface{}, shouldFollowLogs interface{}) *MockKurtosisBackend_GetUserServiceLogs_Call {
	return &MockKurtosisBackend_GetUserServiceLogs_Call{Call: _e.mock.On("GetUserServiceLogs", ctx, enclaveId, filters, shouldFollowLogs)}
}

func (_c *MockKurtosisBackend_GetUserServiceLogs_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, filters *service.ServiceFilters, shouldFollowLogs bool)) *MockKurtosisBackend_GetUserServiceLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(*service.ServiceFilters), args[3].(bool))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetUserServiceLogs_Call) Return(successfulUserServiceLogs map[service.ServiceGUID]io.ReadCloser, erroredUserServiceGuids map[service.ServiceGUID]error, resultError error) *MockKurtosisBackend_GetUserServiceLogs_Call {
	_c.Call.Return(successfulUserServiceLogs, erroredUserServiceGuids, resultError)
	return _c
}

// GetUserServices provides a mock function with given fields: ctx, enclaveId, filters
func (_m *MockKurtosisBackend) GetUserServices(ctx context.Context, enclaveId enclave.EnclaveID, filters *service.ServiceFilters) (map[service.ServiceGUID]*service.Service, error) {
	ret := _m.Called(ctx, enclaveId, filters)

	var r0 map[service.ServiceGUID]*service.Service
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, *service.ServiceFilters) map[service.ServiceGUID]*service.Service); ok {
		r0 = rf(ctx, enclaveId, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceGUID]*service.Service)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, *service.ServiceFilters) error); ok {
		r1 = rf(ctx, enclaveId, filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKurtosisBackend_GetUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserServices'
type MockKurtosisBackend_GetUserServices_Call struct {
	*mock.Call
}

// GetUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - filters *service.ServiceFilters
func (_e *MockKurtosisBackend_Expecter) GetUserServices(ctx interface{}, enclaveId interface{}, filters interface{}) *MockKurtosisBackend_GetUserServices_Call {
	return &MockKurtosisBackend_GetUserServices_Call{Call: _e.mock.On("GetUserServices", ctx, enclaveId, filters)}
}

func (_c *MockKurtosisBackend_GetUserServices_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, filters *service.ServiceFilters)) *MockKurtosisBackend_GetUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(*service.ServiceFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_GetUserServices_Call) Return(_a0 map[service.ServiceGUID]*service.Service, _a1 error) *MockKurtosisBackend_GetUserServices_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

// PauseService provides a mock function with given fields: ctx, enclaveId, serviceId
func (_m *MockKurtosisBackend) PauseService(ctx context.Context, enclaveId enclave.EnclaveID, serviceId service.ServiceGUID) error {
	ret := _m.Called(ctx, enclaveId, serviceId)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, service.ServiceGUID) error); ok {
		r0 = rf(ctx, enclaveId, serviceId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_PauseService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PauseService'
type MockKurtosisBackend_PauseService_Call struct {
	*mock.Call
}

// PauseService is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - serviceId service.ServiceGUID
func (_e *MockKurtosisBackend_Expecter) PauseService(ctx interface{}, enclaveId interface{}, serviceId interface{}) *MockKurtosisBackend_PauseService_Call {
	return &MockKurtosisBackend_PauseService_Call{Call: _e.mock.On("PauseService", ctx, enclaveId, serviceId)}
}

func (_c *MockKurtosisBackend_PauseService_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, serviceId service.ServiceGUID)) *MockKurtosisBackend_PauseService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(service.ServiceGUID))
	})
	return _c
}

func (_c *MockKurtosisBackend_PauseService_Call) Return(resultErr error) *MockKurtosisBackend_PauseService_Call {
	_c.Call.Return(resultErr)
	return _c
}

// RegisterUserServices provides a mock function with given fields: ctx, enclaveId, services
func (_m *MockKurtosisBackend) RegisterUserServices(ctx context.Context, enclaveId enclave.EnclaveID, services map[service.ServiceID]bool) (map[service.ServiceID]*service.ServiceRegistration, map[service.ServiceID]error, error) {
	ret := _m.Called(ctx, enclaveId, services)

	var r0 map[service.ServiceID]*service.ServiceRegistration
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, map[service.ServiceID]bool) map[service.ServiceID]*service.ServiceRegistration); ok {
		r0 = rf(ctx, enclaveId, services)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceID]*service.ServiceRegistration)
		}
	}

	var r1 map[service.ServiceID]error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, map[service.ServiceID]bool) map[service.ServiceID]error); ok {
		r1 = rf(ctx, enclaveId, services)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveID, map[service.ServiceID]bool) error); ok {
		r2 = rf(ctx, enclaveId, services)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_RegisterUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterUserServices'
type MockKurtosisBackend_RegisterUserServices_Call struct {
	*mock.Call
}

// RegisterUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - services map[service.ServiceID]bool
func (_e *MockKurtosisBackend_Expecter) RegisterUserServices(ctx interface{}, enclaveId interface{}, services interface{}) *MockKurtosisBackend_RegisterUserServices_Call {
	return &MockKurtosisBackend_RegisterUserServices_Call{Call: _e.mock.On("RegisterUserServices", ctx, enclaveId, services)}
}

func (_c *MockKurtosisBackend_RegisterUserServices_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, services map[service.ServiceID]bool)) *MockKurtosisBackend_RegisterUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(map[service.ServiceID]bool))
	})
	return _c
}

func (_c *MockKurtosisBackend_RegisterUserServices_Call) Return(_a0 map[service.ServiceID]*service.ServiceRegistration, _a1 map[service.ServiceID]error, _a2 error) *MockKurtosisBackend_RegisterUserServices_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

// RunNetworkingSidecarExecCommands provides a mock function with given fields: ctx, enclaveId, networkingSidecarsCommands
func (_m *MockKurtosisBackend) RunNetworkingSidecarExecCommands(ctx context.Context, enclaveId enclave.EnclaveID, networkingSidecarsCommands map[service.ServiceGUID][]string) (map[service.ServiceGUID]*exec_result.ExecResult, map[service.ServiceGUID]error, error) {
	ret := _m.Called(ctx, enclaveId, networkingSidecarsCommands)

	var r0 map[service.ServiceGUID]*exec_result.ExecResult
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID][]string) map[service.ServiceGUID]*exec_result.ExecResult); ok {
		r0 = rf(ctx, enclaveId, networkingSidecarsCommands)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceGUID]*exec_result.ExecResult)
		}
	}

	var r1 map[service.ServiceGUID]error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID][]string) map[service.ServiceGUID]error); ok {
		r1 = rf(ctx, enclaveId, networkingSidecarsCommands)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceGUID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID][]string) error); ok {
		r2 = rf(ctx, enclaveId, networkingSidecarsCommands)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_RunNetworkingSidecarExecCommands_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunNetworkingSidecarExecCommands'
type MockKurtosisBackend_RunNetworkingSidecarExecCommands_Call struct {
	*mock.Call
}

// RunNetworkingSidecarExecCommands is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - networkingSidecarsCommands map[service.ServiceGUID][]string
func (_e *MockKurtosisBackend_Expecter) RunNetworkingSidecarExecCommands(ctx interface{}, enclaveId interface{}, networkingSidecarsCommands interface{}) *MockKurtosisBackend_RunNetworkingSidecarExecCommands_Call {
	return &MockKurtosisBackend_RunNetworkingSidecarExecCommands_Call{Call: _e.mock.On("RunNetworkingSidecarExecCommands", ctx, enclaveId, networkingSidecarsCommands)}
}

func (_c *MockKurtosisBackend_RunNetworkingSidecarExecCommands_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, networkingSidecarsCommands map[service.ServiceGUID][]string)) *MockKurtosisBackend_RunNetworkingSidecarExecCommands_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(map[service.ServiceGUID][]string))
	})
	return _c
}

func (_c *MockKurtosisBackend_RunNetworkingSidecarExecCommands_Call) Return(successfulNetworkingSidecarExecResults map[service.ServiceGUID]*exec_result.ExecResult, erroredUserServiceGuids map[service.ServiceGUID]error, resultErr error) *MockKurtosisBackend_RunNetworkingSidecarExecCommands_Call {
	_c.Call.Return(successfulNetworkingSidecarExecResults, erroredUserServiceGuids, resultErr)
	return _c
}

// RunUserServiceExecCommands provides a mock function with given fields: ctx, enclaveId, userServiceCommands
func (_m *MockKurtosisBackend) RunUserServiceExecCommands(ctx context.Context, enclaveId enclave.EnclaveID, userServiceCommands map[service.ServiceGUID][]string) (map[service.ServiceGUID]*exec_result.ExecResult, map[service.ServiceGUID]error, error) {
	ret := _m.Called(ctx, enclaveId, userServiceCommands)

	var r0 map[service.ServiceGUID]*exec_result.ExecResult
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID][]string) map[service.ServiceGUID]*exec_result.ExecResult); ok {
		r0 = rf(ctx, enclaveId, userServiceCommands)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceGUID]*exec_result.ExecResult)
		}
	}

	var r1 map[service.ServiceGUID]error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID][]string) map[service.ServiceGUID]error); ok {
		r1 = rf(ctx, enclaveId, userServiceCommands)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceGUID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID][]string) error); ok {
		r2 = rf(ctx, enclaveId, userServiceCommands)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_RunUserServiceExecCommands_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunUserServiceExecCommands'
type MockKurtosisBackend_RunUserServiceExecCommands_Call struct {
	*mock.Call
}

// RunUserServiceExecCommands is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - userServiceCommands map[service.ServiceGUID][]string
func (_e *MockKurtosisBackend_Expecter) RunUserServiceExecCommands(ctx interface{}, enclaveId interface{}, userServiceCommands interface{}) *MockKurtosisBackend_RunUserServiceExecCommands_Call {
	return &MockKurtosisBackend_RunUserServiceExecCommands_Call{Call: _e.mock.On("RunUserServiceExecCommands", ctx, enclaveId, userServiceCommands)}
}

func (_c *MockKurtosisBackend_RunUserServiceExecCommands_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, userServiceCommands map[service.ServiceGUID][]string)) *MockKurtosisBackend_RunUserServiceExecCommands_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(map[service.ServiceGUID][]string))
	})
	return _c
}

func (_c *MockKurtosisBackend_RunUserServiceExecCommands_Call) Return(succesfulUserServiceExecResults map[service.ServiceGUID]*exec_result.ExecResult, erroredUserServiceGuids map[service.ServiceGUID]error, resultErr error) *MockKurtosisBackend_RunUserServiceExecCommands_Call {
	_c.Call.Return(succesfulUserServiceExecResults, erroredUserServiceGuids, resultErr)
	return _c
}

// StartRegisteredUserServices provides a mock function with given fields: ctx, enclaveId, services
func (_m *MockKurtosisBackend) StartRegisteredUserServices(ctx context.Context, enclaveId enclave.EnclaveID, services map[service.ServiceGUID]*service.ServiceConfig) (map[service.ServiceGUID]*service.Service, map[service.ServiceGUID]error, error) {
	ret := _m.Called(ctx, enclaveId, services)

	var r0 map[service.ServiceGUID]*service.Service
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID]*service.ServiceConfig) map[service.ServiceGUID]*service.Service); ok {
		r0 = rf(ctx, enclaveId, services)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceGUID]*service.Service)
		}
	}

	var r1 map[service.ServiceGUID]error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID]*service.ServiceConfig) map[service.ServiceGUID]error); ok {
		r1 = rf(ctx, enclaveId, services)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceGUID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID]*service.ServiceConfig) error); ok {
		r2 = rf(ctx, enclaveId, services)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_StartRegisteredUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartRegisteredUserServices'
type MockKurtosisBackend_StartRegisteredUserServices_Call struct {
	*mock.Call
}

// StartRegisteredUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - services map[service.ServiceGUID]*service.ServiceConfig
func (_e *MockKurtosisBackend_Expecter) StartRegisteredUserServices(ctx interface{}, enclaveId interface{}, services interface{}) *MockKurtosisBackend_StartRegisteredUserServices_Call {
	return &MockKurtosisBackend_StartRegisteredUserServices_Call{Call: _e.mock.On("StartRegisteredUserServices", ctx, enclaveId, services)}
}

func (_c *MockKurtosisBackend_StartRegisteredUserServices_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, services map[service.ServiceGUID]*service.ServiceConfig)) *MockKurtosisBackend_StartRegisteredUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(map[service.ServiceGUID]*service.ServiceConfig))
	})
	return _c
}

func (_c *MockKurtosisBackend_StartRegisteredUserServices_Call) Return(_a0 map[service.ServiceGUID]*service.Service, _a1 map[service.ServiceGUID]error, _a2 error) *MockKurtosisBackend_StartRegisteredUserServices_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

// StopAPIContainers provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) StopAPIContainers(ctx context.Context, filters *api_container.APIContainerFilters) (map[enclave.EnclaveID]bool, map[enclave.EnclaveID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveID]bool
	if rf, ok := ret.Get(0).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveID]bool)
		}
	}

	var r1 map[enclave.EnclaveID]error
	if rf, ok := ret.Get(1).(func(context.Context, *api_container.APIContainerFilters) map[enclave.EnclaveID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *api_container.APIContainerFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_StopAPIContainers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopAPIContainers'
type MockKurtosisBackend_StopAPIContainers_Call struct {
	*mock.Call
}

// StopAPIContainers is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *api_container.APIContainerFilters
func (_e *MockKurtosisBackend_Expecter) StopAPIContainers(ctx interface{}, filters interface{}) *MockKurtosisBackend_StopAPIContainers_Call {
	return &MockKurtosisBackend_StopAPIContainers_Call{Call: _e.mock.On("StopAPIContainers", ctx, filters)}
}

func (_c *MockKurtosisBackend_StopAPIContainers_Call) Run(run func(ctx context.Context, filters *api_container.APIContainerFilters)) *MockKurtosisBackend_StopAPIContainers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*api_container.APIContainerFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_StopAPIContainers_Call) Return(successfulApiContainerIds map[enclave.EnclaveID]bool, erroredApiContainerIds map[enclave.EnclaveID]error, resultErr error) *MockKurtosisBackend_StopAPIContainers_Call {
	_c.Call.Return(successfulApiContainerIds, erroredApiContainerIds, resultErr)
	return _c
}

// StopEnclaves provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) StopEnclaves(ctx context.Context, filters *enclave.EnclaveFilters) (map[enclave.EnclaveID]bool, map[enclave.EnclaveID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[enclave.EnclaveID]bool
	if rf, ok := ret.Get(0).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[enclave.EnclaveID]bool)
		}
	}

	var r1 map[enclave.EnclaveID]error
	if rf, ok := ret.Get(1).(func(context.Context, *enclave.EnclaveFilters) map[enclave.EnclaveID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[enclave.EnclaveID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *enclave.EnclaveFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_StopEnclaves_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopEnclaves'
type MockKurtosisBackend_StopEnclaves_Call struct {
	*mock.Call
}

// StopEnclaves is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *enclave.EnclaveFilters
func (_e *MockKurtosisBackend_Expecter) StopEnclaves(ctx interface{}, filters interface{}) *MockKurtosisBackend_StopEnclaves_Call {
	return &MockKurtosisBackend_StopEnclaves_Call{Call: _e.mock.On("StopEnclaves", ctx, filters)}
}

func (_c *MockKurtosisBackend_StopEnclaves_Call) Run(run func(ctx context.Context, filters *enclave.EnclaveFilters)) *MockKurtosisBackend_StopEnclaves_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*enclave.EnclaveFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_StopEnclaves_Call) Return(successfulEnclaveIds map[enclave.EnclaveID]bool, erroredEnclaveIds map[enclave.EnclaveID]error, resultErr error) *MockKurtosisBackend_StopEnclaves_Call {
	_c.Call.Return(successfulEnclaveIds, erroredEnclaveIds, resultErr)
	return _c
}

// StopEngines provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) StopEngines(ctx context.Context, filters *engine.EngineFilters) (map[engine.EngineGUID]bool, map[engine.EngineGUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[engine.EngineGUID]bool
	if rf, ok := ret.Get(0).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[engine.EngineGUID]bool)
		}
	}

	var r1 map[engine.EngineGUID]error
	if rf, ok := ret.Get(1).(func(context.Context, *engine.EngineFilters) map[engine.EngineGUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[engine.EngineGUID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *engine.EngineFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_StopEngines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopEngines'
type MockKurtosisBackend_StopEngines_Call struct {
	*mock.Call
}

// StopEngines is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *engine.EngineFilters
func (_e *MockKurtosisBackend_Expecter) StopEngines(ctx interface{}, filters interface{}) *MockKurtosisBackend_StopEngines_Call {
	return &MockKurtosisBackend_StopEngines_Call{Call: _e.mock.On("StopEngines", ctx, filters)}
}

func (_c *MockKurtosisBackend_StopEngines_Call) Run(run func(ctx context.Context, filters *engine.EngineFilters)) *MockKurtosisBackend_StopEngines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*engine.EngineFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_StopEngines_Call) Return(successfulEngineGuids map[engine.EngineGUID]bool, erroredEngineGuids map[engine.EngineGUID]error, resultErr error) *MockKurtosisBackend_StopEngines_Call {
	_c.Call.Return(successfulEngineGuids, erroredEngineGuids, resultErr)
	return _c
}

// StopNetworkingSidecars provides a mock function with given fields: ctx, filters
func (_m *MockKurtosisBackend) StopNetworkingSidecars(ctx context.Context, filters *networking_sidecar.NetworkingSidecarFilters) (map[service.ServiceGUID]bool, map[service.ServiceGUID]error, error) {
	ret := _m.Called(ctx, filters)

	var r0 map[service.ServiceGUID]bool
	if rf, ok := ret.Get(0).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) map[service.ServiceGUID]bool); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceGUID]bool)
		}
	}

	var r1 map[service.ServiceGUID]error
	if rf, ok := ret.Get(1).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) map[service.ServiceGUID]error); ok {
		r1 = rf(ctx, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceGUID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *networking_sidecar.NetworkingSidecarFilters) error); ok {
		r2 = rf(ctx, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_StopNetworkingSidecars_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopNetworkingSidecars'
type MockKurtosisBackend_StopNetworkingSidecars_Call struct {
	*mock.Call
}

// StopNetworkingSidecars is a helper method to define mock.On call
//   - ctx context.Context
//   - filters *networking_sidecar.NetworkingSidecarFilters
func (_e *MockKurtosisBackend_Expecter) StopNetworkingSidecars(ctx interface{}, filters interface{}) *MockKurtosisBackend_StopNetworkingSidecars_Call {
	return &MockKurtosisBackend_StopNetworkingSidecars_Call{Call: _e.mock.On("StopNetworkingSidecars", ctx, filters)}
}

func (_c *MockKurtosisBackend_StopNetworkingSidecars_Call) Run(run func(ctx context.Context, filters *networking_sidecar.NetworkingSidecarFilters)) *MockKurtosisBackend_StopNetworkingSidecars_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*networking_sidecar.NetworkingSidecarFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_StopNetworkingSidecars_Call) Return(successfulUserServiceGuids map[service.ServiceGUID]bool, erroredUserServiceGuids map[service.ServiceGUID]error, resultErr error) *MockKurtosisBackend_StopNetworkingSidecars_Call {
	_c.Call.Return(successfulUserServiceGuids, erroredUserServiceGuids, resultErr)
	return _c
}

// StopUserServices provides a mock function with given fields: ctx, enclaveId, filters
func (_m *MockKurtosisBackend) StopUserServices(ctx context.Context, enclaveId enclave.EnclaveID, filters *service.ServiceFilters) (map[service.ServiceGUID]bool, map[service.ServiceGUID]error, error) {
	ret := _m.Called(ctx, enclaveId, filters)

	var r0 map[service.ServiceGUID]bool
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, *service.ServiceFilters) map[service.ServiceGUID]bool); ok {
		r0 = rf(ctx, enclaveId, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceGUID]bool)
		}
	}

	var r1 map[service.ServiceGUID]error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, *service.ServiceFilters) map[service.ServiceGUID]error); ok {
		r1 = rf(ctx, enclaveId, filters)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceGUID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveID, *service.ServiceFilters) error); ok {
		r2 = rf(ctx, enclaveId, filters)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_StopUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopUserServices'
type MockKurtosisBackend_StopUserServices_Call struct {
	*mock.Call
}

// StopUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - filters *service.ServiceFilters
func (_e *MockKurtosisBackend_Expecter) StopUserServices(ctx interface{}, enclaveId interface{}, filters interface{}) *MockKurtosisBackend_StopUserServices_Call {
	return &MockKurtosisBackend_StopUserServices_Call{Call: _e.mock.On("StopUserServices", ctx, enclaveId, filters)}
}

func (_c *MockKurtosisBackend_StopUserServices_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, filters *service.ServiceFilters)) *MockKurtosisBackend_StopUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(*service.ServiceFilters))
	})
	return _c
}

func (_c *MockKurtosisBackend_StopUserServices_Call) Return(successfulUserServiceGuids map[service.ServiceGUID]bool, erroredUserServiceGuids map[service.ServiceGUID]error, resultErr error) *MockKurtosisBackend_StopUserServices_Call {
	_c.Call.Return(successfulUserServiceGuids, erroredUserServiceGuids, resultErr)
	return _c
}

// UnpauseService provides a mock function with given fields: ctx, enclaveId, serviceId
func (_m *MockKurtosisBackend) UnpauseService(ctx context.Context, enclaveId enclave.EnclaveID, serviceId service.ServiceGUID) error {
	ret := _m.Called(ctx, enclaveId, serviceId)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, service.ServiceGUID) error); ok {
		r0 = rf(ctx, enclaveId, serviceId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKurtosisBackend_UnpauseService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnpauseService'
type MockKurtosisBackend_UnpauseService_Call struct {
	*mock.Call
}

// UnpauseService is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - serviceId service.ServiceGUID
func (_e *MockKurtosisBackend_Expecter) UnpauseService(ctx interface{}, enclaveId interface{}, serviceId interface{}) *MockKurtosisBackend_UnpauseService_Call {
	return &MockKurtosisBackend_UnpauseService_Call{Call: _e.mock.On("UnpauseService", ctx, enclaveId, serviceId)}
}

func (_c *MockKurtosisBackend_UnpauseService_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, serviceId service.ServiceGUID)) *MockKurtosisBackend_UnpauseService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(service.ServiceGUID))
	})
	return _c
}

func (_c *MockKurtosisBackend_UnpauseService_Call) Return(resultErr error) *MockKurtosisBackend_UnpauseService_Call {
	_c.Call.Return(resultErr)
	return _c
}

// UnregisterUserServices provides a mock function with given fields: ctx, enclaveId, services
func (_m *MockKurtosisBackend) UnregisterUserServices(ctx context.Context, enclaveId enclave.EnclaveID, services map[service.ServiceGUID]bool) (map[service.ServiceGUID]bool, map[service.ServiceGUID]error, error) {
	ret := _m.Called(ctx, enclaveId, services)

	var r0 map[service.ServiceGUID]bool
	if rf, ok := ret.Get(0).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID]bool) map[service.ServiceGUID]bool); ok {
		r0 = rf(ctx, enclaveId, services)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[service.ServiceGUID]bool)
		}
	}

	var r1 map[service.ServiceGUID]error
	if rf, ok := ret.Get(1).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID]bool) map[service.ServiceGUID]error); ok {
		r1 = rf(ctx, enclaveId, services)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[service.ServiceGUID]error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, enclave.EnclaveID, map[service.ServiceGUID]bool) error); ok {
		r2 = rf(ctx, enclaveId, services)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockKurtosisBackend_UnregisterUserServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnregisterUserServices'
type MockKurtosisBackend_UnregisterUserServices_Call struct {
	*mock.Call
}

// UnregisterUserServices is a helper method to define mock.On call
//   - ctx context.Context
//   - enclaveId enclave.EnclaveID
//   - services map[service.ServiceGUID]bool
func (_e *MockKurtosisBackend_Expecter) UnregisterUserServices(ctx interface{}, enclaveId interface{}, services interface{}) *MockKurtosisBackend_UnregisterUserServices_Call {
	return &MockKurtosisBackend_UnregisterUserServices_Call{Call: _e.mock.On("UnregisterUserServices", ctx, enclaveId, services)}
}

func (_c *MockKurtosisBackend_UnregisterUserServices_Call) Run(run func(ctx context.Context, enclaveId enclave.EnclaveID, services map[service.ServiceGUID]bool)) *MockKurtosisBackend_UnregisterUserServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(enclave.EnclaveID), args[2].(map[service.ServiceGUID]bool))
	})
	return _c
}

func (_c *MockKurtosisBackend_UnregisterUserServices_Call) Return(_a0 map[service.ServiceGUID]bool, _a1 map[service.ServiceGUID]error, _a2 error) *MockKurtosisBackend_UnregisterUserServices_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

type mockConstructorTestingTNewMockKurtosisBackend interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockKurtosisBackend creates a new instance of MockKurtosisBackend. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockKurtosisBackend(t mockConstructorTestingTNewMockKurtosisBackend) *MockKurtosisBackend {
	mock := &MockKurtosisBackend{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
