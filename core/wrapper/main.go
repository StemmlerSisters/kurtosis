/*
 * Copyright (c) 2020 - present Kurtosis Technologies LLC.
 * All Rights Reserved.
 */

package main

import (
	"flag"
	"fmt"
	"github.com/kurtosis-tech/kurtosis/commons/logrus_log_levels"
	"github.com/kurtosis-tech/kurtosis/initializer/initializer_container_constants"
	"github.com/palantir/stacktrace"
	"github.com/sirupsen/logrus"
	"os"
	"path"
	"strings"
	"text/template"
)

const (
	// "Enum" of actions
	StoreTrue Action =  iota
	StoreValue

	flagPrefix = "--"

	failureExitCode = 1
)

type Action int

type FlagArgParsingData struct {
	Flag string
	Variable string
	DoStoreTrue bool
	DoStoreValue bool
}

type TemplateData struct {
	DefaultValues map[string]string

	KurtosisCoreVersion string

	NumPositionalArgs int

	// List of variables whose value can't be empty after parsing
	RequiredVariables []string

	FlagArgParsingData []FlagArgParsingData

	OneLinerHelpText string
	LinewiseHelpText []string
}

type Argument struct {
	// If empty, this is a positional Argument
	Flag string

	// The Bash Variable that the value will be stored to
	Variable string

	// The default Variable that the Bash Variable will be assigned to, if not present
	DefaultVal string

	// The Variable HelpText
	HelpText string

	// The Action taken (only relevant for Flag variables; position variables will always store the value)
	Action Action
}

var args = []Argument{
	{
		Flag:       "--custom-env-vars-json",
		Variable:   "custom_env_vars_json",
		DefaultVal: "{}",
		HelpText:   "JSON containing key-value mappings of custom environment variables that will be passed through to the Dockerfile of the test suite container, e.g. '{\"MY_VAR\": \"/some/value\"}'",
		Action:     StoreValue,
	},
	{
		Flag:       "--client-id",
		Variable:   "client_id",
		DefaultVal: "",
		HelpText:   "An OAuth client ID which is needed for running Kurtosis in CI, and should be left empty when running Kurtosis on a local machine",
		Action:     StoreValue,
	},
	{
		Flag:       "--client-secret",
		Variable:   "client_secret",
		DefaultVal: "",
		HelpText:   "An OAuth client secret which is needed for running Kurtosis in CI, and should be left empty when running Kurtosis on a local machine",
		Action:     StoreValue,
	},
	{
		Flag:       "--help",
		Variable:   "show_help",
		DefaultVal: "false",
		HelpText:   "Display this message",
		Action:     StoreTrue,
	},
	{
		Flag:       "--kurtosis-log-level",
		Variable:   "kurtosis_log_level",
		DefaultVal: "info",
		HelpText: fmt.Sprintf(
			"The log level that all output generated by the Kurtosis framework itself should log at (%v)",
			strings.Join(logrus_log_levels.AcceptableLogLevels, "|"),
		),
		Action:     StoreValue,
	},
	{
		Flag:       "--list",
		Variable:   "do_list",
		DefaultVal: "false",
		HelpText:   "Rather than running the tests, lists the tests available to run",
		Action:     StoreTrue,
	},
	{
		Flag:       "--parallelism",
		Variable:   "parallelism",
		DefaultVal: "4",
		HelpText:   "The number of texts to execute in parallel",
		Action:     StoreValue,
	},
	{
		Flag:       "--tests",
		Variable:   "test_names",
		DefaultVal: "",
		HelpText:   "List of test names to run, separated by '" + initializer_container_constants.TestNameArgSeparator + "' (default or empty: run all tests)",
		Action:     StoreValue,
	},
	{
		Flag:       "--test-suite-log-level",
		Variable:   "test_suite_log_level",
		DefaultVal: "info",
		HelpText: fmt.Sprintf("A string that will be passed as-is to the test suite container to indicate what log level the test suite container should output at; this string should be meaningful to the test suite container because Kurtosis won't know what logging framework the testsuite uses"),
		Action:     StoreValue,
	},
	{
		Variable:   "test_suite_image",
		HelpText:   "The Docker image containing the testsuite to execute",
	},
}

// Fills the Bash wrapper script template with the appropriate variables
func main()  {
	kurtosisCoreVersionArg := flag.String(
		"kurtosis-core-version",
		"",
		"Version of Kurtosis core to generate the wrapper script with",
	)
	templateFilepathArg := flag.String(
		"template",
		"",
		"Filepath containing Bash template file that will get rendered into the Kurtosis wrapper script",
	)
	outputFilepathArg := flag.String(
		"output",
		"",
		"Output filepath to write the rendered template to",
	)
	flag.Parse()

	// For some reason, the template name has to match teh basename of the file:
	//  https://stackoverflow.com/questions/49043292/error-template-is-an-incomplete-or-empty-template
	templateFilename := path.Base(*templateFilepathArg)
	tmpl, err := template.New(templateFilename).ParseFiles(*templateFilepathArg)
	if err != nil {
		logrus.Errorf("An error occurred parsing the Bash template: %v", err)
		os.Exit(failureExitCode)
	}

	data, err := generateTemplateData(args, *kurtosisCoreVersionArg)
	if err != nil {
		logrus.Errorf("An error occurred generating the template data: %v", err)
		os.Exit(failureExitCode)
	}

	fp, err := os.Create(*outputFilepathArg)
	if err != nil {
		logrus.Errorf("An error occurred opening the output file for writing: %v", err)
		os.Exit(failureExitCode)
	}
	defer fp.Close()

	if err := tmpl.Execute(fp, data); err != nil {
		logrus.Errorf("An error occurred filling the template: %v", err)
		os.Exit(failureExitCode)
	}
}

/*
Gets the text that an arg should have on the one-liner representation (e.g. "--parallelism parallelism")
 */
func getOneLinerText(arg Argument) (string, error) {
	isFlagArg := arg.Flag != ""

	var onelinerText string
	if isFlagArg {
		if (arg.Action == StoreValue) {
			onelinerText = fmt.Sprintf("%v %v", arg.Flag, arg.Variable)
		} else if (arg.Action == StoreTrue) {
			onelinerText = arg.Flag
		} else {
			return "", stacktrace.NewError("Unrecognized arg Action '%v'; this is a code bug", arg.Action)
		}
	} else {
		onelinerText = arg.Variable
	}
	return onelinerText, nil
}

func padStringToLength(str string, desiredLength int) string {
	numSpacesToAdd := desiredLength - len(str)
	return str + strings.Repeat(" ", numSpacesToAdd)
}

func generateTemplateData(args []Argument, kurtosisCoreVersion string) (*TemplateData, error) {
	// Validate arguments
	seenFlags := map[string]bool{}
	for _, arg := range args {
		isFlagArg := arg.Flag != ""
		if isFlagArg {
			if _, found := seenFlags[arg.Flag]; found {
				return nil, stacktrace.NewError(
					"Duplicate flag '%v'",
					arg.Flag)
			}
			if !strings.HasPrefix(arg.Flag, flagPrefix) {
				return nil, stacktrace.NewError(
					"Flag '%v' must start with flag prefix '%v'",
					arg.Flag,
					flagPrefix)
			}
		} else {
			if arg.DefaultVal != "" {
				return nil, stacktrace.NewError(
					"Positional argument '%v' cannot have default value",
					arg.Variable,
					flagPrefix)
			}
		}
	}

	// Get the longest one-liner text (which is the title of the argument in linewise display)
	longestOneLinerText := 0
	for _, arg := range args {
		oneLinerText, err := getOneLinerText(arg)
		if err != nil {
			return nil, stacktrace.Propagate(
				err,
				"An error occurred getting oneliner text for arg with variable '%v' while calculating max pad length",
				arg.Variable)
		}
		if len(oneLinerText) > longestOneLinerText {
			longestOneLinerText = len(oneLinerText)
		}
	}

	allFlagArgParsingData := []FlagArgParsingData{}
	defaultValues := map[string]string{}
	requiredVariables := []string{}
	numPositionalArgs := 0

	flagArgsOnelinerFragments := []string{}
	positionalArgsOnelinerFragments := []string{}
	flagArgsLinewiseHelptext := []string{}
	positionalArgsLinewiseHelptext := []string{}
	for _, arg := range args {
		defaultValues[arg.Variable] = arg.DefaultVal

		oneLinerText, err := getOneLinerText(arg)
		if err != nil {
			return nil, stacktrace.Propagate(err, "An error occurred getting oneliner text for arg with variable '%v' while building template data", arg.Variable)
		}
		paddedOneLinerText := padStringToLength(oneLinerText, longestOneLinerText + 3)

		isFlagArg := arg.Flag != ""
		if isFlagArg {
			flagArgParsingData := FlagArgParsingData{
				Flag:         arg.Flag,
				Variable:     arg.Variable,
				DoStoreTrue:  arg.Action == StoreTrue,
				DoStoreValue: arg.Action == StoreValue,
			}
			allFlagArgParsingData = append(allFlagArgParsingData, flagArgParsingData)

			flagArgsOnelinerFragments = append(
				flagArgsOnelinerFragments,
				fmt.Sprintf("[%v]", oneLinerText),
			)

			var linewiseText string
			if (arg.DefaultVal != "") {
				linewiseText = fmt.Sprintf(
					"%v%v (default: %v)",
					paddedOneLinerText,
					arg.HelpText,
					arg.DefaultVal,
				)
			} else {
				linewiseText = fmt.Sprintf(
					"%v%v",
					paddedOneLinerText,
					arg.HelpText,
				)
			}
			flagArgsLinewiseHelptext = append(
				flagArgsLinewiseHelptext,
				fmt.Sprintf("   %v", linewiseText),
			)
		} else {
			numPositionalArgs++
			requiredVariables = append(requiredVariables, arg.Variable)

			positionalArgsOnelinerFragments = append(
				positionalArgsOnelinerFragments,
				oneLinerText,
			)
			linewiseText := fmt.Sprintf(
				"%v%v",
				paddedOneLinerText,
				arg.HelpText,
			)
			positionalArgsLinewiseHelptext = append(
				positionalArgsLinewiseHelptext,
				fmt.Sprintf("   %v", linewiseText),
			)
		}
	}
	flagArgsOneliner := strings.Join(flagArgsOnelinerFragments, " ")
	positionalArgsOneliner := strings.Join(positionalArgsOnelinerFragments, " ")
	combinedOneliner := fmt.Sprintf("%v %v", flagArgsOneliner, positionalArgsOneliner)

	combinedLinewiseHelptext := append(flagArgsLinewiseHelptext, positionalArgsLinewiseHelptext...)
	return &TemplateData{
		DefaultValues:      defaultValues,
		FlagArgParsingData: allFlagArgParsingData,
		KurtosisCoreVersion: kurtosisCoreVersion,
		NumPositionalArgs: numPositionalArgs,
		RequiredVariables:  requiredVariables,
		OneLinerHelpText:   combinedOneliner,
		LinewiseHelpText:   combinedLinewiseHelptext,
	}, nil
}



