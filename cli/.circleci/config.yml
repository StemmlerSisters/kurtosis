version: 2.1

orbs:
  kurtosis-docs-checker: kurtosis-tech/docs-checker@0.2.0

executors:
  ubuntu_vm:
    machine:
      image: ubuntu-2004:202111-01

parameters:
  # To upgrade the Docker Engine version, see which versions are supported at: https://circleci.com/docs/2.0/building-docker-images/#docker-version
  docker-engine-version:
    type: string
    default: 20.10.7
  cimg-base-version:
    type: string
    default: 2021.11-20.04
  go-version:
    type: string
    default: 1.15.13
  goreleaser-version:
    type: string
    default: "v0.183.0"
  # The prefix that will be attached to the files generated by saving REPL images to TGZs, so they can be transferred across jobs
  saved-repl-image-file-prefix:
    type: string
    default: "saved-docker-image-for-repl-"
  # The name of the directory inside the REPLs subproject directory where the REPL images will be saved
  saved-repl-image-dirname:
    type: string
    default: "saved-docker-images"
  # The dirpath in jobs that use the built CLI binary where the workspace containing the CLI binary will be attached
  workspace-with-cli-binary-mountpoint:
    type: string
    default: "/tmp/workspace"
  # The dirpath where CLI dist subdirectories are found, relative to the workspace root
  cli-dist-home-relative-dirpath:
    type: string
    default: "cli/dist"
  # The filepath where the Linux AMD 64 CLI binary can be found, relative to the cli-dist-home-relative-dirpath
  cli-linux-amd-64-binary-relative-filepath:
    type: string
    default: "cli_linux_amd64/kurtosis"


# NOTE: Because CircleCI jobs run on separate machines from each other, we duplicate steps (like checkout) between jobs. This is because doing the "correct" DRY
#  refactoring of, "one job for checkout, one job for build Docker image, etc." would require a) persisting files between jobs and b) persisting Docker images between
#  jobs. Both are annoying (saving/loading workspaces require re-downloading the workspace over the network, and there doesn't seem to be a good way to do Docker
#  images), so we run everything inside a single job.
# See also: https://discuss.circleci.com/t/can-docker-images-be-preserved-between-jobs-in-a-workflow-without-a-manual-load-save/23388/12
jobs:
  # -- Build jobs ------------------------------------------
  build_repls:
    docker:
      - image: "cimg/go:<< pipeline.parameters.go-version>>"
    steps:
      - checkout
      - setup_remote_docker:
          version: "<< pipeline.parameters.docker-engine-version >>"
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin
      # The 'git config' and 'go env' steps are to allow Go to read modules from our private Github repos
      # The KURTOSISBOT_GITHUB_TOKEN is a secret provided at CI build time
      - run: |
          git config --global url."https://${KURTOSISBOT_GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
          go env -w "GOPRIVATE=github.com/kurtosis-tech/*"
          repls/scripts/build.sh

      # We save the Docker images to files so we can persist them to workspace so the REPL image-publishing job can use them (if it's running)
      - run: |
          repls_dirpath="${PWD}/repls"
          output_dirpath="${repls_dirpath}/<< pipeline.parameters.saved-repl-image-dirname >>"

          mkdir "${output_dirpath}"
          docker_image_tag="$(bash "./scripts/get-docker-images-tag.sh")"

          source "${repls_dirpath}/scripts/_constants.env"
          for repl_image_dirpath in $(bash "${repls_dirpath}/scripts/_list-repl-image-dirpaths.sh"); do
            repl_type="$(basename "${repl_image_dirpath}")"
            docker_image_and_tag="${DOCKER_IMAGE_PREFIX}${repl_type}${DOCKER_IMAGE_SUFFIX}:${docker_image_tag}"
            output_filepath="${output_dirpath}/<< pipeline.parameters.saved-repl-image-file-prefix >>${repl_type}"
            docker save -o "${output_filepath}" "${docker_image_and_tag}"
          done
      - persist_to_workspace:
          root: .
          paths: 
            - "./repls/<< pipeline.parameters.saved-repl-image-dirname >>"

  build_cli:
    docker:
      - image: "goreleaser/goreleaser:<< pipeline.parameters.goreleaser-version >>"
    steps:
      - checkout
      # The 'git config' and 'go env' steps are to allow Go to read modules from our private Github repos
      # The KURTOSISBOT_GITHUB_TOKEN is a secret provided at CI build time
      - run: |
          git config --global url."https://${KURTOSISBOT_GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
          go env -w "GOPRIVATE=github.com/kurtosis-tech/*"
          cli/scripts/build.sh
      - persist_to_workspace:
          root: .
          paths: 
            - "./<< pipeline.parameters.cli-dist-home-relative-dirpath >>"

  build_golang_testsuite:
    executor: ubuntu_vm
    steps:
      - checkout
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>"
      # We call Kurtosis a bunch later, so add it to the PATH so we can call it easily
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin
      #Run config init to avoid metrics consent prompt when execute engine start command,
      #We do not send metrics from CI to not dirty the metrics data
      - run: "${KURTOSIS_BINPATH} config init dont-send-metrics"
      - run: "${KURTOSIS_BINPATH} engine start"

      # Run the testsuite, but don't fail the job immediately so that we can upload the enclave dump
      - run: |
          if ! ./internal_testsuites/golang/scripts/build.sh; then
            touch /tmp/testsuite-failed
          fi

      # Dump enclave data so we can debug any issues that arise
      - run: |
          cd /tmp
          output_dirname="enclave-dumps"
          mkdir "${output_dirname}"
          for enclave_id in $("${KURTOSIS_BINPATH}" enclave ls | tail -n+2 | awk '{print $1}'); do
            "${KURTOSIS_BINPATH}" enclave dump "${enclave_id}" "${output_dirname}/${enclave_id}"
          done
          zip -r "${output_dirname}.zip" "${output_dirname}"
      - store_artifacts:
          path: /tmp/enclave-dumps.zip
          destination: enclave-dumps.zip

      # Finally, fail the job if the testsuite failed
      - run: "! [ -f /tmp/testsuite-failed ]"

  build_typescript_testsuite:
    executor: ubuntu_vm
    steps:
      - checkout
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>"
      # We call Kurtosis a bunch later, so add it to the PATH so we can call it easily
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin

      #Run install Yarn because TypeScript tests are managed with Yarn package manager
      - run: npm install -g yarn

      #Run config init to avoid metrics consent prompt when execute engine start command,
      #We do not send metrics from CI to not dirty the metrics data
      - run: "${KURTOSIS_BINPATH} config init dont-send-metrics"
      - run: "${KURTOSIS_BINPATH} engine start"

      # Run the testsuite, but don't fail the job immediately so that we can upload the enclave dump
      - run: |
          if ! ./internal_testsuites/typescript/scripts/build.sh; then
            touch /tmp/testsuite-failed
          fi

      # Dump enclave data so we can debug any issues that arise
      - run: |
          cd /tmp
          output_dirname="enclave-dumps"
          mkdir "${output_dirname}"
          for enclave_id in $("${KURTOSIS_BINPATH}" enclave ls | tail -n+2 | awk '{print $1}'); do
            "${KURTOSIS_BINPATH}" enclave dump "${enclave_id}" "${output_dirname}/${enclave_id}"
          done
          zip -r "${output_dirname}.zip" "${output_dirname}"
      - store_artifacts:
          path: /tmp/enclave-dumps.zip
          destination: enclave-dumps.zip

      # Finally, fail the job if the testsuite failed
      - run: "! [ -f /tmp/testsuite-failed ]"

  # This test will install the currently-available version of Kurtosis, start an enclave, and then see if we can do some basic stuff
  # with it using the newly-built version of Kurtosis
  test_old_enclave_continuity:
    executor: ubuntu_vm
    steps:
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin

      # Set up Kurtosis
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>"
      - run: |
          echo "deb [trusted=yes] https://apt.fury.io/kurtosis-tech/ /" | sudo tee /etc/apt/sources.list.d/kurtosis.list
          sudo apt update
          sudo apt install kurtosis-cli
      # We don't send metrics to avoid polluting our logs
      - run: kurtosis config init dont-send-metrics

      # Start up an enclave with a module and some services inside
      - run: kurtosis module exec --enclave-id old-test-enclave kurtosistech/datastore-army-module --execute-params '{"numDatastores":2}'
      - run: kurtosis engine stop

      # Now use the new CLI & engine and ensure everything still works
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
      - run: "${KURTOSIS_BINPATH} enclave ls"
      - run: "${KURTOSIS_BINPATH} enclave inspect old-test-enclave" 
      - run: "${KURTOSIS_BINPATH} module exec --enclave-id new-test-enclave kurtosistech/datastore-army-module --execute-params '{\"numDatastores\":2}'"
      - run: "${KURTOSIS_BINPATH} enclave ls"
      - run: "${KURTOSIS_BINPATH} enclave rm -f new-test-enclave"
      - run: "${KURTOSIS_BINPATH} clean -a"
      - run: "${KURTOSIS_BINPATH} engine stop"

  # -- End build jobs ---------------------------------------

  # -- Artifact-publishing jobs --------------------------------
  push_repl_images:
    docker:
      - image: "cimg/base:<< pipeline.parameters.cimg-base-version >>"
    steps:
      - checkout
      - attach_workspace:
          at: /tmp/workspace
      - setup_remote_docker:
          version: "<< pipeline.parameters.docker-engine-version>>"
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin
      - run: |
          input_dirpath="/tmp/workspace/repls/<< pipeline.parameters.saved-repl-image-dirname >>"
          for image_filepath in $(find "${input_dirpath}" -type f); do
            docker_load_output="$(docker load -i "${image_filepath}")"
            image_and_tag="$(echo "${docker_load_output}" | awk '{print $NF}')"
            docker push "${image_and_tag}"
          done

  push_cli_artifacts:
    docker:
      - image: "goreleaser/goreleaser:<< pipeline.parameters.goreleaser-version >>"
    steps:
      - checkout
      # The 'git config' and 'go env' steps are to allow Go to read modules from our private Github repos
      # The KURTOSISBOT_GITHUB_TOKEN is a secret provided at CI build time
      - run: |
          git config --global url."https://${KURTOSISBOT_GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
          go env -w "GOPRIVATE=github.com/kurtosis-tech/*"
          cli/scripts/build.sh true
  # -- End artifact-publishing jobs ----------------------------

workflows:
  build:
    jobs:
      # -- Build jobs ------------------------------------------
      - kurtosis-docs-checker/check-docs:
          markdown-link-check-config-json: "{}"
          filters:
            branches:
              ignore:
                - develop
                - master
      - build_repls:
          context:
            - github-user
            - docker-user
          filters:
            branches:
              ignore:
                - develop
                - master
            # Building on tags as well is necessary because the REPL image-publishing job depends on this
            tags: 
              only: /^[0-9]+\.[0-9]+\.[0-9]+$/
      - build_cli:
          context:
            - github-user
          filters:
            branches:
              ignore:
                - develop
                - master
      - build_golang_testsuite:
          context:
            - docker-user
          requires:
            - build_cli
          filters:
            branches:
              ignore:
                - develop
                - master
      - build_typescript_testsuite:
          context:
            - docker-user
          requires:
            - build_cli
          filters:
            branches:
              ignore:
                - develop
                - master
      - test_old_enclave_continuity:
          context:
            - docker-user
          requires:
            - build_cli
          filters:
            branches:
              ignore:
                - develop
                - master
      # -- End build jobs ---------------------------------------

      # -- Artifact-publishing jobs --------------------------------
      - push_repl_images:
          context:
            - docker-user
          requires:
            - build_repls
          filters:
            branches:
              ignore: /.*/
            tags: 
              only: /^[0-9]+\.[0-9]+\.[0-9]+$/
      - push_cli_artifacts:
          context:
            - github-user
            - gemfury-publisher
          filters:
            branches:
              ignore: /.*/
            tags: 
              only: /^[0-9]+\.[0-9]+\.[0-9]+$/
      # -- End artifact-publishing jobs ----------------------------
