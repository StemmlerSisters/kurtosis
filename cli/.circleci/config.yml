version: 2.1

orbs:
  kurtosis-docs-checker: kurtosis-tech/docs-checker@0.2.0

executors:
  ubuntu_vm:
    machine:
      image: ubuntu-2004:202111-01

parameters:
  # To upgrade the Docker Engine version, see which versions are supported at: https://circleci.com/docs/2.0/building-docker-images/#docker-version
  docker-engine-version:
    type: string
    default: 20.10.7
  cimg-base-version:
    type: string
    default: 2021.11-20.04
  go-version:
    type: string
    default: 1.15.13
  goreleaser-version:
    type: string
    default: "v0.183.0"
  # The dirpath in jobs that use the built CLI binary where the workspace containing the CLI binary will be attached
  workspace-with-cli-binary-mountpoint:
    type: string
    default: "/tmp/workspace"
  # The dirpath where CLI dist subdirectories are found, relative to the workspace root
  cli-dist-home-relative-dirpath:
    type: string
    default: "cli/dist"
  # The filepath where the Linux AMD 64 CLI binary can be found, relative to the cli-dist-home-relative-dirpath
  cli-linux-amd-64-binary-relative-filepath:
    type: string
    default: "cli_linux_amd64/kurtosis"
  # The key that the CLI build cache will get
  # We can bump the version here if we ever need to bust the cache
  cli-build-cache-key-prefix:
    type: string
    default: "cli-go-mod-v1"


# NOTE: Because CircleCI jobs run on separate machines from each other, we duplicate steps (like checkout) between jobs. This is because doing the "correct" DRY
#  refactoring of, "one job for checkout, one job for build Docker image, etc." would require a) persisting files between jobs and b) persisting Docker images between
#  jobs. Both are annoying (saving/loading workspaces require re-downloading the workspace over the network, and there doesn't seem to be a good way to do Docker
#  images), so we run everything inside a single job.
# See also: https://discuss.circleci.com/t/can-docker-images-be-preserved-between-jobs-in-a-workflow-without-a-manual-load-save/23388/12
jobs:
  # -- Build jobs ------------------------------------------
  build_cli:
    docker:
      - image: "goreleaser/goreleaser:<< pipeline.parameters.goreleaser-version >>"
    resource_class: large
    steps:
      - checkout
      # The 'git config' and 'go env' steps are to allow Go to read modules from our private Github repos
      # The KURTOSISBOT_GITHUB_TOKEN is a secret provided at CI build time

      # Cache our dependencies
      - restore_cache:
          keys:
            - << pipeline.parameters.cli-build-cache-key-prefix >>-{{ checksum "cli/go.sum" }}

      - run: |
          git config --global url."https://${KURTOSISBOT_GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
          go env -w "GOPRIVATE=github.com/kurtosis-tech/*"
          cli/scripts/build.sh

      - save_cache:
          key: << pipeline.parameters.cli-build-cache-key-prefix >>-{{ checksum "cli/go.sum" }}
          paths:
            - "/go/pkg/mod"
            - "/root/.cache/go-build"

      - persist_to_workspace:
          root: .
          paths: 
            - "./<< pipeline.parameters.cli-dist-home-relative-dirpath >>"

  build_golang_testsuite:
    executor: ubuntu_vm
    steps:
      - checkout
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>"
      # We call Kurtosis a bunch later, so add it to the PATH so we can call it easily
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin
      #Run config init to avoid metrics consent prompt when execute engine start command,
      #We do not send metrics from CI to not dirty the metrics data
      - run: "${KURTOSIS_BINPATH} config init dont-send-metrics"
      - run: "${KURTOSIS_BINPATH} engine start"

      # Run the testsuite, but don't fail the job immediately so that we can upload the enclave dump
      - run: |
          if ! ./internal_testsuites/golang/scripts/build.sh; then
            touch /tmp/testsuite-failed
          fi

      # Dump enclave data so we can debug any issues that arise
      - run: |
          cd /tmp
          output_dirname="enclave-dumps"
          mkdir "${output_dirname}"
          for enclave_id in $("${KURTOSIS_BINPATH}" enclave ls | tail -n+2 | awk '{print $1}'); do
            "${KURTOSIS_BINPATH}" enclave dump "${enclave_id}" "${output_dirname}/${enclave_id}"
          done
          zip -r "${output_dirname}.zip" "${output_dirname}"
      - store_artifacts:
          path: /tmp/enclave-dumps.zip
          destination: enclave-dumps.zip

      # Finally, fail the job if the testsuite failed
      - run: "! [ -f /tmp/testsuite-failed ]"

  build_typescript_testsuite:
    executor: ubuntu_vm
    steps:
      - checkout
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>"
      # We call Kurtosis a bunch later, so add it to the PATH so we can call it easily
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin

      #Run install Yarn because TypeScript tests are managed with Yarn package manager
      - run: npm install -g yarn

      #Run config init to avoid metrics consent prompt when execute engine start command,
      #We do not send metrics from CI to not dirty the metrics data
      - run: "${KURTOSIS_BINPATH} config init dont-send-metrics"
      - run: "${KURTOSIS_BINPATH} engine start"

      # Run the testsuite, but don't fail the job immediately so that we can upload the enclave dump
      - run: |
          if ! ./internal_testsuites/typescript/scripts/build.sh; then
            touch /tmp/testsuite-failed
          fi

      # Dump enclave data so we can debug any issues that arise
      - run: |
          cd /tmp
          output_dirname="enclave-dumps"
          mkdir "${output_dirname}"
          for enclave_id in $("${KURTOSIS_BINPATH}" enclave ls | tail -n+2 | awk '{print $1}'); do
            "${KURTOSIS_BINPATH}" enclave dump "${enclave_id}" "${output_dirname}/${enclave_id}"
          done
          zip -r "${output_dirname}.zip" "${output_dirname}"
      - store_artifacts:
          path: /tmp/enclave-dumps.zip
          destination: enclave-dumps.zip

      # Finally, fail the job if the testsuite failed
      - run: "! [ -f /tmp/testsuite-failed ]"

  # This test will install the currently-available version of Kurtosis, start an enclave, and then see if we can do some basic stuff
  # with it using the newly-built version of Kurtosis
  test_old_enclave_continuity:
    executor: ubuntu_vm
    steps:
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin

      # Set up Kurtosis
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>"
      - run: |
          echo "deb [trusted=yes] https://apt.fury.io/kurtosis-tech/ /" | sudo tee /etc/apt/sources.list.d/kurtosis.list
          sudo apt update
          sudo apt install kurtosis-cli
      # We don't send metrics to avoid polluting our logs
      - run: kurtosis config init dont-send-metrics

      # Start up an enclave with a module and some services inside
      - run: kurtosis module exec --enclave-id running-old-enclave kurtosistech/datastore-army-module --execute-params '{"numDatastores":2}'
      - run: kurtosis module exec --enclave-id stopped-old-enclave kurtosistech/datastore-army-module --execute-params '{"numDatastores":2}'
      - run: kurtosis enclave stop stopped-old-enclave
      - run: kurtosis engine stop

      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"

      # Make sure we can still interact with the old enclaves
      - run: "${KURTOSIS_BINPATH} enclave ls"
      - run: "${KURTOSIS_BINPATH} enclave inspect running-old-enclave" 
      - run: "${KURTOSIS_BINPATH} service add running-old-enclave test-service httpd --ports http=80"
      - run: "${KURTOSIS_BINPATH} enclave stop running-old-enclave" 
      - run: "${KURTOSIS_BINPATH} enclave inspect stopped-old-enclave" 

      # Ensure modules & enclaves still work
      - run: "${KURTOSIS_BINPATH} clean -a"
      - run: "${KURTOSIS_BINPATH} engine stop"

      # Ensure everything got cleaned up successfully
      - run:
          name: "Verify only the engine container remains after the clean"
          command: |
            if ! [ "$(docker container ls -a | tail -n+2 | wc -l)" -eq 1 ]; then
              docker container ls -a
              false
            fi
      - run: 
          name: "Verify Kurtosis cleaned up all its volumes"
          command: |
            if ! [ $(docker volume ls | tail -n+2 | wc -l) -eq 0 ]; then
              docker volume ls
              false
            fi
      - run: 
          name: "Verify Kurtosis cleaned up all its networks"
          command: |
            builtin_network_ids=(
              "$(docker network ls --quiet --filter "name=host")"
              "$(docker network ls --quiet --filter "name=bridge")"
              "$(docker network ls --quiet --filter "name=none")"
            )
            if ! [ $(docker network ls | grep -v -f <(printf "%s\n" "${builtin_network_ids[@]}") | tail -n+2 | wc -l) -eq 0 ]; then
              docker network ls
              false
            fi

  test_basic_cli_functionality:
    executor: ubuntu_vm
    steps:
      - run: echo "${DOCKER_PASSWORD}" | docker login -u ${DOCKER_USERNAME} --password-stdin

      # Set up Kurtosis
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>"
      - run: |
          echo "deb [trusted=yes] https://apt.fury.io/kurtosis-tech/ /" | sudo tee /etc/apt/sources.list.d/kurtosis.list
          sudo apt update
          sudo apt install kurtosis-cli
      # We don't send metrics to avoid polluting our logs
      - run: kurtosis config init dont-send-metrics
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"

      # Basic service add & rm
      - run: "${KURTOSIS_BINPATH} enclave new --id test-enclave"
      - run: "${KURTOSIS_BINPATH} service add test-enclave test1 httpd --ports http=80"
      - run: "${KURTOSIS_BINPATH} service rm test-enclave test1"
      - run: "${KURTOSIS_BINPATH} service add test-enclave test1 httpd --ports http=80"
      - run: "${KURTOSIS_BINPATH} service add test-enclave test2 httpd --ports http=80"

      # Module inside an enclave
      - run: "${KURTOSIS_BINPATH} module exec --enclave-id test-enclave kurtosistech/datastore-army-module --execute-params '{\"numDatastores\":2}'"
      - run: "${KURTOSIS_BINPATH} enclave ls"
      - run: "${KURTOSIS_BINPATH} enclave inspect test-enclave"
      - run: "${KURTOSIS_BINPATH} enclave stop test-enclave"
      - run: "${KURTOSIS_BINPATH} enclave inspect test-enclave"   # Ensure we can still inspect stopped enclaves
      - run: "${KURTOSIS_BINPATH} clean -a"
      - run: "${KURTOSIS_BINPATH} engine stop"

      # Ensure everything got cleaned up successfully
      - run:
          name: "Verify only the engine container remains after the clean"
          command: |
            if ! [ "$(docker container ls -a | tail -n+2 | wc -l)" -eq 1 ]; then
              docker container ls -a
              false
            fi
      - run: 
          name: "Verify Kurtosis cleaned up all its volumes"
          command: |
            if ! [ $(docker volume ls | tail -n+2 | wc -l) -eq 0 ]; then
              docker volume ls
              false
            fi
      - run: 
          name: "Verify Kurtosis cleaned up all its networks"
          command: |
            builtin_network_ids=(
              "$(docker network ls --quiet --filter "name=host")"
              "$(docker network ls --quiet --filter "name=bridge")"
              "$(docker network ls --quiet --filter "name=none")"
            )
            if ! [ $(docker network ls | grep -v -f <(printf "%s\n" "${builtin_network_ids[@]}") | tail -n+2 | wc -l) -eq 0 ]; then
              docker network ls
              false
            fi

  test_config_init_edge_cases:
    executor: ubuntu_vm
    steps:
      - checkout
      - attach_workspace:
          at: "<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>"
      - run: |
          echo 'export KURTOSIS_BINPATH="<< pipeline.parameters.workspace-with-cli-binary-mountpoint >>/<< pipeline.parameters.cli-dist-home-relative-dirpath >>/<< pipeline.parameters.cli-linux-amd-64-binary-relative-filepath >>"' >> "${BASH_ENV}"
      - run: |
          function test_config_init_is_required() {
            if ${KURTOSIS_BINPATH} engine start; then
              echo "Error: Expected an attempt to use the Kurtosis CLI in a non-interactive terminal without init'ing the config first to fail but it succeeded" >&2
              return 1
            fi
          }

          function test_double_config_init_without_force_fails() {
            "${KURTOSIS_BINPATH}" config init dont-send-metrics

            if "${KURTOSIS_BINPATH}" config init dont-send-metrics; then
              echo "Error: Expected init'ing the config twice in a non-interactive terminal to throw an error but none was thrown" >&2
              return 1
            fi
          }

          function test_double_config_init_with_force_succeeds() {
            "${KURTOSIS_BINPATH}" config init dont-send-metrics

            if ! "${KURTOSIS_BINPATH}" config init -f dont-send-metrics; then
              echo "Error: Expected a forced config init in a non-interactive terminal to succeed but it failed" >&2
              return 1
            fi
          }

          all_tests_succeeded="true"
          for test_func in test_config_init_is_required test_double_config_init_without_force_fails test_double_config_init_with_force_succeeds; do
            # Reset test state
            rm -f "$("${KURTOSIS_BINPATH}" config path)"

            if ! "${test_func}"; then
              echo "Error: Expected test function '${test_func}' to succeed but it failed" >&2
              all_tests_succeeded="false"
            fi
          done

          "${all_tests_succeeded}"

  # -- End build jobs ---------------------------------------

  # -- Artifact-publishing jobs --------------------------------
  push_cli_artifacts:
    docker:
      - image: "goreleaser/goreleaser:<< pipeline.parameters.goreleaser-version >>"
    steps:
      - checkout
      # The 'git config' and 'go env' steps are to allow Go to read modules from our private Github repos
      # The KURTOSISBOT_GITHUB_TOKEN is a secret provided at CI build time
      - run: |
          git config --global url."https://${KURTOSISBOT_GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
          go env -w "GOPRIVATE=github.com/kurtosis-tech/*"
          cli/scripts/build.sh true
  # -- End artifact-publishing jobs ----------------------------

workflows:
  build:
    jobs:
      # -- Build jobs ------------------------------------------
      - kurtosis-docs-checker/check-docs:
          markdown-link-check-config-json: "{}"
          filters:
            branches:
              ignore:
                - develop
                - master
      - build_cli:
          context:
            - github-user
          filters:
            branches:
              ignore:
                - develop
                - master
      - build_golang_testsuite:
          context:
            - docker-user
          requires:
            - build_cli
          filters:
            branches:
              ignore:
                - develop
                - master
      - build_typescript_testsuite:
          context:
            - docker-user
          requires:
            - build_cli
          filters:
            branches:
              ignore:
                - develop
                - master
      - test_basic_cli_functionality:
          context:
            - docker-user
          requires:
            - build_cli
          filters:
            branches:
              ignore:
                - develop
                - master
      - test_old_enclave_continuity:
          context:
            - docker-user
          requires:
            - build_cli
          filters:
            branches:
              ignore:
                - develop
                - master
      - test_config_init_edge_cases:
          requires:
            - build_cli
          filters:
            branches:
              ignore:
                - develop
                - master
      # -- End build jobs ---------------------------------------

      # -- Artifact-publishing jobs --------------------------------
      - push_cli_artifacts:
          context:
            - github-user
            - gemfury-publisher
          filters:
            branches:
              ignore: /.*/
            tags: 
              only: /^[0-9]+\.[0-9]+\.[0-9]+$/
      # -- End artifact-publishing jobs ----------------------------
