package exec

import (
	"context"
	"fmt"
	"github.com/kurtosis-tech/kurtosis/api/golang/core/kurtosis_core_rpc_api_bindings"
	"github.com/kurtosis-tech/kurtosis/api/golang/core/lib/enclaves"
	"github.com/kurtosis-tech/kurtosis/api/golang/engine/lib/kurtosis_context"
	"github.com/kurtosis-tech/kurtosis/cli/cli/command_framework/lowlevel"
	"github.com/kurtosis-tech/kurtosis/cli/cli/command_framework/lowlevel/args"
	"github.com/kurtosis-tech/kurtosis/cli/cli/command_framework/lowlevel/flags"
	"github.com/kurtosis-tech/kurtosis/cli/cli/command_str_consts"
	"github.com/kurtosis-tech/kurtosis/cli/cli/helpers/enclave_ids"
	"github.com/kurtosis-tech/stacktrace"
	"github.com/sirupsen/logrus"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"
)

const (
	scriptOrModulePathKey = "script-or-module-path"
	startosisExtension    = ".star"

	enclaveIdFlagKey                   = "enclave-id"
	defaultEnclaveId                   = ""
	disallowedCharInEnclaveIdRegexp    = "[^-A-Za-z0-9.]+"
	enclaveIdDisallowedCharReplacement = "-"

	isPartitioningEnabledFlagKey = "with-partitioning"
	defaultIsPartitioningEnabled = false

	scriptArgForLogging = "script"
	moduleArgForLogging = "module"
)

var StartosisExecCmd = &lowlevel.LowlevelKurtosisCommand{
	CommandStr:       command_str_consts.StartosisExecCmdStr,
	ShortDescription: "Execute a Startosis script or module",
	LongDescription: "Execute a Startosis module or script in an enclave. For a script we expect a path to a " + startosisExtension +
		" file. For a module we expect path to a directory containing kurtosis.mod. If the enclave-id param is provided, Kurtosis " +
		"will exec the script inside this enclave, or create it if it doesn't exist. If no enclave-id param is " +
		"provided, Kurtosis will create a new enclave with a default name derived from the script or module name.",
	Flags: []*flags.FlagConfig{
		{
			Key: enclaveIdFlagKey,
			Usage: fmt.Sprintf(
				"The enclave ID in which the script or module will be executed, which must match regex '%v' (default: "+
					"use a string derived from the script or module filename and the current Unix time). An enclave with this "+
					"ID will be created if it doesn't exist.",
				enclave_ids.AllowedEnclaveIdCharsRegexStr,
			),
			Type:    flags.FlagType_String,
			Default: defaultEnclaveId,
		},
		{
			Key: isPartitioningEnabledFlagKey,
			Usage: "If set to true, the enclave that the module executes in will have partitioning enabled so " +
				"network partitioning simulations can be run",
			Type:    flags.FlagType_Bool,
			Default: strconv.FormatBool(defaultIsPartitioningEnabled),
		},
	},
	Args: []*args.ArgConfig{
		&args.ArgConfig{
			// for a module we expect a path to a directory
			// for a script we expect a script with a `.star` extension
			// TODO add a `Usage` description here when ArgConfig supports it
			Key:            scriptOrModulePathKey,
			IsOptional:     false,
			DefaultValue:   "",
			IsGreedy:       false,
			ValidationFunc: validateScriptOrModulePath,
		},
	},
	RunFunc: run,
}

func run(
	ctx context.Context,
	flags *flags.ParsedFlags,
	args *args.ParsedArgs,
) error {
	// Args parsing and validation
	userRequestedEnclaveId, err := flags.GetString(enclaveIdFlagKey)
	if err != nil {
		return stacktrace.Propagate(err, "An error occurred getting the enclave ID using flag key '%s'", enclaveIdFlagKey)
	}
	isPartitioningEnabled, err := flags.GetBool(isPartitioningEnabledFlagKey)
	if err != nil {
		return stacktrace.Propagate(err, "An error occurred getting the is-partitioning-enabled setting using flag key '%v'", isPartitioningEnabledFlagKey)
	}

	startosisScriptOrModulePath, err := args.GetNonGreedyArg(scriptOrModulePathKey)
	if err != nil {
		return stacktrace.Propagate(err, "Error reading the Startosis script or module dir at '%s'. Does it exist?", startosisScriptOrModulePath)
	}

	// Get or create enclave in Kurtosis
	enclaveIdStr := userRequestedEnclaveId
	if userRequestedEnclaveId == defaultEnclaveId {
		enclaveIdStr = getAutoGeneratedEnclaveIdStr(startosisScriptOrModulePath)
	}
	err = enclave_ids.ValidateEnclaveId(enclaveIdStr)
	if err != nil {
		return stacktrace.Propagate(err, "Invalid enclave ID '%s'", enclaveIdStr)
	}
	enclaveId := enclaves.EnclaveID(enclaveIdStr)

	kurtosisCtx, err := kurtosis_context.NewKurtosisContextFromLocalEngine()
	if err != nil {
		return stacktrace.Propagate(err, "An error occurred connecting to the local Kurtosis engine")
	}

	enclaveCtx, err := getOrCreateEnclaveContext(ctx, enclaveId, kurtosisCtx, isPartitioningEnabled)
	if err != nil {
		return stacktrace.Propagate(err, "An error occurred getting the enclave context for enclave '%v'", enclaveId)
	}

	fileOrDir, err := os.Stat(startosisScriptOrModulePath)
	if err != nil {
		return stacktrace.Propagate(err, "There was an error reading file or module from disk at '%v'", startosisScriptOrModulePath)
	}

	if fileOrDir.Mode().IsRegular() {
		if !strings.HasSuffix(startosisScriptOrModulePath, startosisExtension) {
			return stacktrace.Propagate(err, "Expected a script with a '%s' extension but got file '%v' with a different extension", startosisExtension, startosisScriptOrModulePath)
		}
		err = executeScript(enclaveCtx, startosisScriptOrModulePath)
		if err != nil {
			return stacktrace.Propagate(err, "An error occurred while executing script '%v'", startosisScriptOrModulePath)
		}
		return nil
	}

	err = executeModule(enclaveCtx, startosisScriptOrModulePath)
	if err != nil {
		return stacktrace.Propagate(err, "An error occurred while running the module '%v'", startosisScriptOrModulePath)
	}

	return nil
}

func validateScriptOrModulePath(_ context.Context, _ *flags.ParsedFlags, args *args.ParsedArgs) error {
	scriptOrModulePath, err := args.GetNonGreedyArg(scriptOrModulePathKey)
	if err != nil {
		return stacktrace.Propagate(err, "Unable to get argument '%s'", scriptOrModulePathKey)
	}

	scriptOrModulePath = strings.TrimSpace(scriptOrModulePath)
	if scriptOrModulePath == "" {
		return stacktrace.NewError("Received an empty '%v'. It should be a non empty string.", scriptOrModulePathKey)
	}

	fileInfo, err := os.Stat(scriptOrModulePath)
	if err != nil {
		return stacktrace.Propagate(err, "Error reading script file or module dir '%s'", scriptOrModulePath)
	}
	if !fileInfo.Mode().IsRegular() && !fileInfo.Mode().IsDir() {
		return stacktrace.Propagate(err, "Script or module path should point to a file on disk or to a directory '%s'", scriptOrModulePath)
	}
	return nil
}

func executeScript(enclaveCtx *enclaves.EnclaveContext, scriptPath string) error {
	fileContentBytes, err := os.ReadFile(scriptPath)
	if err != nil {
		return stacktrace.Propagate(err, "Unable to read content of Startosis script file '%s'", scriptPath)
	}

	executionResponse, err := enclaveCtx.ExecuteStartosisScript(string(fileContentBytes))
	if err != nil {
		return stacktrace.Propagate(err, "An unexpected error occurred executing the Startosis script '%s'", scriptPath)
	}

	err = validateExecutionResponse(executionResponse, scriptPath, scriptArgForLogging)
	if err != nil {
		return stacktrace.Propagate(err, "Ran into a few errors while interpreting, validating or executing the script '%v'", scriptPath)
	}

	return nil
}

func executeModule(enclaveCtx *enclaves.EnclaveContext, modulePath string) error {
	executionResponse, err := enclaveCtx.ExecuteStartosisModule(modulePath)
	if err != nil {
		return stacktrace.Propagate(err, "An unexpected error occurred executing the Startosis module '%s'", modulePath)
	}

	err = validateExecutionResponse(executionResponse, modulePath, moduleArgForLogging)
	if err != nil {
		return stacktrace.Propagate(err, "Ran into a few errors while interpreting, validating or executing the module '%v'", modulePath)
	}

	return nil
}

func validateExecutionResponse(executionResponse *kurtosis_core_rpc_api_bindings.ExecuteStartosisResponse, scriptOrModulePath string, scriptOrModuleArg string) error {
	if executionResponse.InterpretationError != "" {
		return stacktrace.NewError("There was an error interpreting the Startosis %s '%s': \n%v", scriptOrModuleArg, scriptOrModulePath, executionResponse.InterpretationError)
	}
	if len(executionResponse.ValidationErrors) > 0 {
		return stacktrace.NewError("There was an error validating the Startosis %s '%s': \n%v", scriptOrModuleArg, scriptOrModulePath, executionResponse.ValidationErrors)
	}
	if executionResponse.ExecutionError != "" {
		return stacktrace.NewError("There was an error executing the Startosis %s '%s': \n%v", scriptOrModuleArg, scriptOrModulePath, executionResponse.ExecutionError)
	}

	logrus.Infof("Startosis %s executed successfully. Output of the module was: \n%v", scriptOrModuleArg, executionResponse.SerializedScriptOutput)
	return nil
}

func getAutoGeneratedEnclaveIdStr(scriptFilePath string) string {
	pattern := regexp.MustCompile(disallowedCharInEnclaveIdRegexp)
	cleanedEnclaveIdStr := pattern.ReplaceAllString(filepath.Base(scriptFilePath), enclaveIdDisallowedCharReplacement)

	epochStrSuffix := fmt.Sprintf("--%v", time.Now().Unix())
	// Enclave IDs have a max length. Truncate filename if it's too long here
	filenameMaxLength := enclave_ids.EnclaveIdMaxLength - len(epochStrSuffix)
	if len(cleanedEnclaveIdStr) > filenameMaxLength {
		cleanedEnclaveIdStr = cleanedEnclaveIdStr[:filenameMaxLength]
	}
	return fmt.Sprintf("%v%v", cleanedEnclaveIdStr, epochStrSuffix)
}

func getOrCreateEnclaveContext(ctx context.Context, enclaveId enclaves.EnclaveID, kurtosisContext *kurtosis_context.KurtosisContext, isPartitioningEnabled bool) (*enclaves.EnclaveContext, error) {
	enclavesMap, err := kurtosisContext.GetEnclaves(ctx)
	if err != nil {
		return nil, stacktrace.Propagate(err, "Unable to get existing enclaves from Kurtosis backend")
	}
	if _, found := enclavesMap[enclaveId]; found {
		enclaveContext, err := kurtosisContext.GetEnclaveContext(ctx, enclaveId)
		if err != nil {
			return nil, stacktrace.Propagate(err, "Unable to get enclave context from the existing enclave '%s'", enclaveId)
		}
		return enclaveContext, nil
	}
	enclaveContext, err := kurtosisContext.CreateEnclave(ctx, enclaveId, isPartitioningEnabled)
	if err != nil {
		return nil, stacktrace.Propagate(err, fmt.Sprintf("Unable to create new enclave with ID '%s'", enclaveId))
	}
	return enclaveContext, nil
}
